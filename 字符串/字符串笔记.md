# 字符串算法完整指南与学习总结

## 📖 目录

1. [字符串算法概览](#1-字符串算法概览)
2. [基础字符串操作](#2-基础字符串操作)
3. [双指针技术详解](#3-双指针技术详解)
4. [滑动窗口算法](#4-滑动窗口算法)
5. [KMP算法深入理解](#5-kmp算法深入理解)
6. [字符串匹配算法对比](#6-字符串匹配算法对比)
7. [动态规划在字符串中的应用](#7-动态规划在字符串中的应用)
8. [高级字符串算法](#8-高级字符串算法)
9. [题型识别与算法选择](#9-题型识别与算法选择)
10. [个人错误总结与改进](#10-个人错误总结与改进)
11. [经典题目分类汇总](#11-经典题目分类汇总)
12. [复习检查清单](#12-复习检查清单)

---

## 1. 字符串算法概览

### 1.1 字符串的本质
- **字符串 = 字符数组**：在C++中，string本质上是char的容器
- **索引访问**：`s[i]` 访问第i个字符（从0开始）
- **长度获取**：`s.size()` 或 `s.length()`
- **字符比较**：直接用 `==`、`!=`、`<`、`>` 等

### 1.2 算法复杂度对比

| 算法类型 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|-----------|-----------|----------|
| 暴力匹配 | O(n×m) | O(1) | 小数据量，简单匹配 |
| 双指针 | O(n) | O(1) | 对称性问题，双端操作 |
| 滑动窗口 | O(n) | O(k) | 连续子串，动态条件 |
| KMP | O(n+m) | O(m) | 大数据量字符串匹配 |
| 动态规划 | O(n×m) | O(n×m) | 最优化问题 |

### 1.3 字符串算法分类树

```
字符串算法
├── 基础操作
│   ├── 遍历与访问
│   ├── 拼接与分割
│   └── 大小写转换
├── 模式匹配
│   ├── 暴力匹配
│   ├── KMP算法
│   ├── Boyer-Moore
│   └── Rabin-Karp
├── 双指针技术
│   ├── 对撞指针
│   ├── 快慢指针
│   └── 固定间距指针
├── 滑动窗口
│   ├── 固定窗口
│   ├── 可变窗口
│   └── 多指针窗口
├── 动态规划
│   ├── 最长公共子序列
│   ├── 最长公共子串
│   └── 编辑距离
└── 高级技术
    ├── 字典树(Trie)
    ├── 后缀数组
    └── Manacher算法
```

---

## 2. 基础字符串操作

### 2.1 字符与ASCII码

```cpp
// 字符与数字的转换
char c = 'A';
int ascii = c;           // 'A' = 65
int digit = c - '0';     // '5' - '0' = 5

// 大小写转换
char lower = c + 32;     // 'A' + 32 = 'a'
char upper = c - 32;     // 'a' - 32 = 'A'

// 判断字符类型
bool isDigit = (c >= '0' && c <= '9');
bool isLower = (c >= 'a' && c <= 'z');
bool isUpper = (c >= 'A' && c <= 'Z');
```

### 2.2 字符串基本操作

```cpp
#include <string>
using namespace std;

string s = "Hello World";

// 长度
int len = s.size();           // 11
int len2 = s.length();        // 11

// 访问
char first = s[0];            // 'H'
char last = s[s.size()-1];    // 'd'

// 子串
string sub = s.substr(0, 5);  // "Hello"
string sub2 = s.substr(6);    // "World"

// 查找
int pos = s.find("World");    // 6
bool found = (pos != string::npos);

// 拼接
string result = s + "!";      // "Hello World!"
s += " C++";                  // "Hello World C++"

// 插入与删除
s.insert(5, ",");             // "Hello, World C++"
s.erase(5, 1);               // "Hello World C++"

// 替换
s.replace(6, 5, "C++");       // "Hello C++ C++"
```

### 2.3 字符数组操作技巧

```cpp
// 快速初始化
int count[26] = {0};          // 统计26个字母
bool used[128] = {false};     // ASCII字符标记

// 字符到索引的映射
int index = c - 'a';          // 'a'->0, 'b'->1, ...
int index2 = c - 'A';         // 'A'->0, 'B'->1, ...
int index3 = c;               // 直接用ASCII码做索引

// 数组清空技巧
memset(count, 0, sizeof(count));
fill(used, used + 128, false);
```

---

## 3. 双指针技术详解

### 3.1 对撞指针（最常用）

**适用场景**：回文检测、字符串反转、两数之和等

```cpp
// 模板代码
void twoPointers(string& s) {
    int left = 0;
    int right = s.size() - 1;
    
    while (left < right) {
        // 处理逻辑
        if (满足条件) {
            // 同时移动
            left++;
            right--;
        } else {
            // 选择性移动
            if (某条件) left++;
            else right--;
        }
    }
}
```

**经典应用1：反转字符串**
```cpp
void reverseString(vector<char>& s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
}
```

**经典应用2：验证回文串**
```cpp
bool isPalindrome(string s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        // 跳过非字母数字字符
        while (left < right && !isalnum(s[left])) left++;
        while (left < right && !isalnum(s[right])) right--;
        
        // 比较字符（忽略大小写）
        if (tolower(s[left]) != tolower(s[right])) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

### 3.2 快慢指针

**适用场景**：去除重复、数组压缩

```cpp
// 去除重复字符模板
int removeDuplicates(string& s) {
    int slow = 0;  // 慢指针：写入位置
    int fast = 0;  // 快指针：读取位置
    
    while (fast < s.size()) {
        if (应该保留的条件) {
            s[slow] = s[fast];
            slow++;
        }
        fast++;
    }
    
    return slow;  // 新长度
}
```

### 3.3 固定间距指针

**适用场景**：删除倒数第N个节点、字符串间距操作

```cpp
// 寻找倒数第k个位置
int findKthFromEnd(string s, int k) {
    int fast = 0, slow = 0;
    
    // fast先走k步
    for (int i = 0; i < k && fast < s.size(); i++) {
        fast++;
    }
    
    // 同时移动直到fast到达末尾
    while (fast < s.size()) {
        fast++;
        slow++;
    }
    
    return slow;  // slow指向倒数第k个位置
}
```

### 3.4 双指针常见错误与注意事项

**❌ 常见错误**：
1. **边界处理**：`left <= right` vs `left < right`
2. **指针更新**：忘记移动指针导致死循环
3. **越界访问**：没有检查数组边界
4. **逻辑错误**：条件判断写反

**✅ 最佳实践**：
```cpp
// 安全的双指针模板
while (left < right) {
    // 先检查边界
    if (left >= s.size() || right < 0) break;
    
    // 处理逻辑
    if (condition) {
        // 处理
        left++;
        right--;
    } else {
        // 单向移动要小心
        left++;  // 或 right--
    }
}
```

---

## 4. 滑动窗口算法

### 4.1 滑动窗口的本质

滑动窗口 = **双指针的特殊形式**，用于处理连续子数组/子串问题

**核心思想**：
- **右指针**：扩大窗口，加入新元素
- **左指针**：缩小窗口，移除元素
- **窗口状态**：用哈希表、数组等维护窗口内信息

### 4.2 滑动窗口通用模板

```cpp
int slidingWindow(string s) {
    int left = 0, right = 0;
    int result = 0;
    
    // 窗口状态维护
    unordered_map<char, int> window;
    // 或者用数组：int count[128] = {0};
    
    while (right < s.size()) {
        // 右指针字符
        char c = s[right];
        right++;
        
        // 更新窗口状态
        window[c]++;
        
        // 判断窗口是否需要收缩
        while (窗口需要收缩的条件) {
            // 更新结果（在收缩之前）
            result = max(result, right - left);
            
            // 左指针字符
            char d = s[left];
            left++;
            
            // 更新窗口状态
            window[d]--;
        }
        
        // 更新结果（在收缩之后，某些题目需要在这里更新）
        result = max(result, right - left);
    }
    
    return result;
}
```

### 4.3 固定窗口大小

```cpp
vector<int> fixedWindow(string s, int k) {
    vector<int> result;
    int left = 0;
    
    for (int right = 0; right < s.size(); right++) {
        // 添加右边元素
        // ... 更新窗口状态
        
        // 窗口大小达到k时开始处理
        if (right - left + 1 == k) {
            // 处理当前窗口
            result.push_back(/* 窗口结果 */);
            
            // 移除左边元素，准备下一个窗口
            // ... 更新窗口状态
            left++;
        }
    }
    
    return result;
}
```

### 4.4 可变窗口大小

#### 4.4.1 求最大窗口

```cpp
int maxWindow(string s) {
    int left = 0;
    int maxSize = 0;
    unordered_map<char, int> window;
    
    for (int right = 0; right < s.size(); right++) {
        window[s[right]]++;
        
        // 当窗口不满足条件时收缩
        while (窗口不满足条件) {
            window[s[left]]--;
            if (window[s[left]] == 0) {
                window.erase(s[left]);
            }
            left++;
        }
        
        // 更新最大窗口大小
        maxSize = max(maxSize, right - left + 1);
    }
    
    return maxSize;
}
```

#### 4.4.2 求最小窗口

```cpp
int minWindow(string s) {
    int left = 0;
    int minSize = INT_MAX;
    unordered_map<char, int> window;
    
    for (int right = 0; right < s.size(); right++) {
        window[s[right]]++;
        
        // 当窗口满足条件时收缩
        while (窗口满足条件) {
            // 更新最小窗口大小
            minSize = min(minSize, right - left + 1);
            
            window[s[left]]--;
            if (window[s[left]] == 0) {
                window.erase(s[left]);
            }
            left++;
        }
    }
    
    return minSize == INT_MAX ? 0 : minSize;
}
```

### 4.5 经典滑动窗口题目

#### 无重复字符的最长子串

```cpp
int lengthOfLongestSubstring(string s) {
    int left = 0;
    int maxLen = 0;
    unordered_set<char> window;
    
    for (int right = 0; right < s.size(); right++) {
        // 如果有重复字符，收缩窗口
        while (window.count(s[right])) {
            window.erase(s[left]);
            left++;
        }
        
        // 添加当前字符
        window.insert(s[right]);
        maxLen = max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

#### 最小覆盖子串

```cpp
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0;  // 满足条件的字符个数
    int start = 0, len = INT_MAX;
    
    while (right < s.size()) {
        char c = s[right];
        right++;
        
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) {
                valid++;
            }
        }
        
        // 收缩窗口
        while (valid == need.size()) {
            // 更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            
            char d = s[left];
            left++;
            
            if (need.count(d)) {
                if (window[d] == need[d]) {
                    valid--;
                }
                window[d]--;
            }
        }
    }
    
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

---

## 5. KMP算法深入理解

### 5.1 KMP算法的动机

**暴力匹配的问题**：
```cpp
// 暴力匹配 O(n×m)
int bruteForce(string text, string pattern) {
    for (int i = 0; i <= text.size() - pattern.size(); i++) {
        int j;
        for (j = 0; j < pattern.size(); j++) {
            if (text[i + j] != pattern[j]) {
                break;
            }
        }
        if (j == pattern.size()) {
            return i;  // 找到匹配
        }
    }
    return -1;
}
```

**KMP的改进思想**：
- 利用已经匹配的信息
- 避免重复比较
- 时间复杂度降至O(n+m)

### 5.2 前缀函数（失效函数）

**定义**：对于字符串S的每个位置i，前缀函数π[i]表示S[0...i]的最长相等真前缀和真后缀的长度。

**真前缀/真后缀**：不等于自身的前缀/后缀

```cpp
// 计算前缀函数
vector<int> computePrefix(string pattern) {
    int m = pattern.size();
    vector<int> prefix(m, 0);
    
    for (int i = 1; i < m; i++) {
        int j = prefix[i - 1];
        
        // 回退到合适位置
        while (j > 0 && pattern[i] != pattern[j]) {
            j = prefix[j - 1];
        }
        
        // 匹配成功，长度+1
        if (pattern[i] == pattern[j]) {
            j++;
        }
        
        prefix[i] = j;
    }
    
    return prefix;
}
```

### 5.3 前缀函数计算示例

以pattern = "ababa"为例：

```
位置: 0 1 2 3 4
字符: a b a b a
π:    0 0 1 2 3

详细过程：
i=0: π[0] = 0 (按定义)
i=1: "ab"的最长相等前后缀 = 0, π[1] = 0
i=2: "aba"的最长相等前后缀 = "a", π[2] = 1
i=3: "abab"的最长相等前后缀 = "ab", π[3] = 2  
i=4: "ababa"的最长相等前后缀 = "aba", π[4] = 3
```

### 5.4 KMP匹配算法

```cpp
int KMPSearch(string text, string pattern) {
    vector<int> prefix = computePrefix(pattern);
    int n = text.size(), m = pattern.size();
    int j = 0;  // pattern的指针
    
    for (int i = 0; i < n; i++) {  // text的指针
        // 处理不匹配的情况
        while (j > 0 && text[i] != pattern[j]) {
            j = prefix[j - 1];  // 利用前缀信息跳转
        }
        
        // 匹配成功
        if (text[i] == pattern[j]) {
            j++;
        }
        
        // 完全匹配
        if (j == m) {
            return i - m + 1;  // 返回匹配位置
            // j = prefix[j - 1];  // 继续查找下一个匹配
        }
    }
    
    return -1;  // 未找到匹配
}
```

### 5.5 KMP算法的应用

#### 5.5.1 字符串匹配（strStr）

```cpp
int strStr(string haystack, string needle) {
    if (needle.empty()) return 0;
    return KMPSearch(haystack, needle);
}
```

#### 5.5.2 重复的子字符串

```cpp
bool repeatedSubstringPattern(string s) {
    vector<int> prefix = computePrefix(s);
    int n = s.size();
    int len = n - prefix[n - 1];  // 最小重复单元长度
    
    // 检查是否能整除且有重复
    return prefix[n - 1] != 0 && n % len == 0;
}
```

#### 5.5.3 查找所有匹配位置

```cpp
vector<int> findAllMatches(string text, string pattern) {
    vector<int> result;
    vector<int> prefix = computePrefix(pattern);
    int n = text.size(), m = pattern.size();
    int j = 0;
    
    for (int i = 0; i < n; i++) {
        while (j > 0 && text[i] != pattern[j]) {
            j = prefix[j - 1];
        }
        
        if (text[i] == pattern[j]) {
            j++;
        }
        
        if (j == m) {
            result.push_back(i - m + 1);
            j = prefix[j - 1];  // 继续查找下一个
        }
    }
    
    return result;
}
```

### 5.6 KMP算法优化

#### 5.6.1 KMP改进（避免不必要的比较）

```cpp
vector<int> computePrefixImproved(string pattern) {
    int m = pattern.size();
    vector<int> prefix(m, 0);
    
    for (int i = 1; i < m; i++) {
        int j = prefix[i - 1];
        
        while (j > 0 && pattern[i] != pattern[j]) {
            j = prefix[j - 1];
        }
        
        if (pattern[i] == pattern[j]) {
            j++;
        }
        
        // 改进：如果下一个字符相同，直接跳过
        if (i + 1 < m && pattern[i + 1] == pattern[j]) {
            prefix[i] = prefix[j - 1];
        } else {
            prefix[i] = j;
        }
    }
    
    return prefix;
}
```

---

## 6. 字符串匹配算法对比

### 6.1 算法性能对比

| 算法 | 预处理时间 | 匹配时间 | 空间复杂度 | 适用场景 |
|------|-----------|----------|-----------|----------|
| 暴力匹配 | O(1) | O(n×m) | O(1) | 短模式串 |
| KMP | O(m) | O(n) | O(m) | 长模式串，多次匹配 |
| Boyer-Moore | O(m+σ) | O(n/m)平均 | O(m+σ) | 长模式串，大字符集 |
| Rabin-Karp | O(m) | O(n)平均 | O(1) | 多模式匹配 |

### 6.2 Boyer-Moore算法简介

**核心思想**：从右向左匹配，利用"坏字符规则"和"好后缀规则"跳过更多字符。

```cpp
// Boyer-Moore坏字符规则实现（简化版）
int boyerMooreSimple(string text, string pattern) {
    int n = text.size(), m = pattern.size();
    
    // 构建坏字符表
    int badChar[256];
    fill(badChar, badChar + 256, -1);
    for (int i = 0; i < m; i++) {
        badChar[pattern[i]] = i;
    }
    
    int shift = 0;
    while (shift <= n - m) {
        int j = m - 1;
        
        // 从右向左匹配
        while (j >= 0 && pattern[j] == text[shift + j]) {
            j--;
        }
        
        if (j < 0) {
            return shift;  // 找到匹配
        } else {
            // 坏字符规则
            shift += max(1, j - badChar[text[shift + j]]);
        }
    }
    
    return -1;
}
```

### 6.3 Rabin-Karp算法

**核心思想**：使用哈希函数将字符串转换为数字，比较哈希值而不是字符。

```cpp
int rabinKarp(string text, string pattern) {
    int n = text.size(), m = pattern.size();
    int prime = 101;  // 质数
    int patternHash = 0, textHash = 0;
    int h = 1;
    
    // 计算h = pow(d, m-1) % prime
    for (int i = 0; i < m - 1; i++) {
        h = (h * 256) % prime;
    }
    
    // 计算pattern和text第一个窗口的哈希值
    for (int i = 0; i < m; i++) {
        patternHash = (256 * patternHash + pattern[i]) % prime;
        textHash = (256 * textHash + text[i]) % prime;
    }
    
    // 滑动窗口
    for (int i = 0; i <= n - m; i++) {
        // 哈希值匹配，进行字符串比较确认
        if (patternHash == textHash) {
            bool match = true;
            for (int j = 0; j < m; j++) {
                if (text[i + j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) return i;
        }
        
        // 计算下一个窗口的哈希值
        if (i < n - m) {
            textHash = (256 * (textHash - text[i] * h) + text[i + m]) % prime;
            if (textHash < 0) textHash += prime;
        }
    }
    
    return -1;
}
```

---

## 7. 动态规划在字符串中的应用

### 7.1 最长公共子序列（LCS）

**问题**：给定两个字符串，求最长公共子序列的长度。

```cpp
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

// 空间优化版本
int longestCommonSubsequenceOptimized(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector<int> prev(n + 1, 0), curr(n + 1, 0);
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                curr[j] = prev[j - 1] + 1;
            } else {
                curr[j] = max(prev[j], curr[j - 1]);
            }
        }
        prev = curr;
    }
    
    return prev[n];
}
```

### 7.2 最长公共子串

**问题**：求两个字符串的最长公共连续子串。

```cpp
int longestCommonSubstring(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    int maxLen = 0;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                maxLen = max(maxLen, dp[i][j]);
            } else {
                dp[i][j] = 0;  // 必须连续
            }
        }
    }
    
    return maxLen;
}
```

### 7.3 编辑距离

**问题**：求将字符串s1转换为s2所需的最少操作数（插入、删除、替换）。

```cpp
int minDistance(string word1, string word2) {
    int m = word1.size(), n = word2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));
    
    // 初始化边界条件
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + min({
                    dp[i - 1][j],     // 删除
                    dp[i][j - 1],     // 插入
                    dp[i - 1][j - 1]  // 替换
                });
            }
        }
    }
    
    return dp[m][n];
}
```

### 7.4 回文相关DP问题

#### 7.4.1 最长回文子序列

```cpp
int longestPalindromeSubseq(string s) {
    int n = s.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    
    // 单个字符都是回文
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;
    }
    
    // 按长度递增的顺序填表
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s[i] == s[j]) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[0][n - 1];
}
```

#### 7.4.2 最长回文子串（DP版本）

```cpp
string longestPalindrome(string s) {
    int n = s.size();
    if (n == 0) return "";
    
    vector<vector<bool>> dp(n, vector<bool>(n, false));
    int start = 0, maxLen = 1;
    
    // 单个字符都是回文
    for (int i = 0; i < n; i++) {
        dp[i][i] = true;
    }
    
    // 检查长度为2的子串
    for (int i = 0; i < n - 1; i++) {
        if (s[i] == s[i + 1]) {
            dp[i][i + 1] = true;
            start = i;
            maxLen = 2;
        }
    }
    
    // 检查长度大于2的子串
    for (int len = 3; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s[i] == s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = true;
                start = i;
                maxLen = len;
            }
        }
    }
    
    return s.substr(start, maxLen);
}
```

### 7.5 字符串匹配DP

#### 7.5.1 正则表达式匹配

```cpp
bool isMatch(string s, string p) {
    int m = s.size(), n = p.size();
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
    
    // 空字符串匹配空模式
    dp[0][0] = true;
    
    // 处理模式中的 '*' 可以匹配空字符串的情况
    for (int j = 2; j <= n; j++) {
        if (p[j - 1] == '*') {
            dp[0][j] = dp[0][j - 2];
        }
    }
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (p[j - 1] == '*') {
                // '*' 匹配0个字符
                dp[i][j] = dp[i][j - 2];
                // '*' 匹配多个字符
                if (matches(s[i - 1], p[j - 2])) {
                    dp[i][j] = dp[i][j] || dp[i - 1][j];
                }
            } else {
                if (matches(s[i - 1], p[j - 1])) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
    }
    
    return dp[m][n];
}

private:
bool matches(char s, char p) {
    return p == '.' || s == p;
}
```

#### 7.5.2 通配符匹配

```cpp
bool isMatch(string s, string p) {
    int m = s.size(), n = p.size();
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
    
    dp[0][0] = true;
    
    // 处理模式开头的 '*'
    for (int j = 1; j <= n; j++) {
        if (p[j - 1] == '*') {
            dp[0][j] = true;
        } else {
            break;
        }
    }
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (p[j - 1] == '*') {
                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
            } else if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
    }
    
    return dp[m][n];
}
```

---

## 8. 高级字符串算法

### 8.1 Manacher算法（线性时间求最长回文）

**传统方法**：中心扩展法O(n²)，DP方法O(n²)
**Manacher算法**：O(n)时间复杂度

```cpp
string preprocess(string s) {
    if (s.empty()) return "^$";
    string ret = "^";
    for (char c : s) {
        ret += "#" + string(1, c);
    }
    ret += "#$";
    return ret;
}

string longestPalindrome(string s) {
    string T = preprocess(s);
    int n = T.size();
    vector<int> P(n, 0);
    int center = 0, right = 0;
    
    for (int i = 1; i < n - 1; i++) {
        int mirror = 2 * center - i;
        
        if (i < right) {
            P[i] = min(right - i, P[mirror]);
        }
        
        // 尝试扩展回文
        while (T[i + P[i] + 1] == T[i - P[i] - 1]) {
            P[i]++;
        }
        
        // 如果回文扩展超过了right，更新center和right
        if (i + P[i] > right) {
            center = i;
            right = i + P[i];
        }
    }
    
    // 找到最长回文
    int maxLen = 0, centerIndex = 0;
    for (int i = 1; i < n - 1; i++) {
        if (P[i] > maxLen) {
            maxLen = P[i];
            centerIndex = i;
        }
    }
    
    int start = (centerIndex - maxLen) / 2;
    return s.substr(start, maxLen);
}
```

### 8.2 字典树（Trie）

**用途**：前缀匹配、单词搜索、自动补全

```cpp
class TrieNode {
public:
    TrieNode* children[26];
    bool isEnd;
    
    TrieNode() {
        for (int i = 0; i < 26; i++) {
            children[i] = nullptr;
        }
        isEnd = false;
    }
};

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (node->children[index] == nullptr) {
                node->children[index] = new TrieNode();
            }
            node = node->children[index];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (node->children[index] == nullptr) {
                return false;
            }
            node = node->children[index];
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* node = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (node->children[index] == nullptr) {
                return false;
            }
            node = node->children[index];
        }
        return true;
    }
    
    // 获取所有以prefix开头的单词
    vector<string> getWordsWithPrefix(string prefix) {
        vector<string> result;
        TrieNode* node = root;
        
        // 先找到prefix的位置
        for (char c : prefix) {
            int index = c - 'a';
            if (node->children[index] == nullptr) {
                return result;
            }
            node = node->children[index];
        }
        
        // DFS收集所有单词
        dfs(node, prefix, result);
        return result;
    }
    
private:
    void dfs(TrieNode* node, string current, vector<string>& result) {
        if (node->isEnd) {
            result.push_back(current);
        }
        
        for (int i = 0; i < 26; i++) {
            if (node->children[i] != nullptr) {
                dfs(node->children[i], current + char('a' + i), result);
            }
        }
    }
};
```

### 8.3 后缀数组（Suffix Array）

**用途**：快速字符串匹配、最长公共前缀、重复子串查找

```cpp
class SuffixArray {
private:
    string s;
    vector<int> sa, rank, lcp;
    
public:
    SuffixArray(string str) : s(str) {
        buildSuffixArray();
        buildLCP();
    }
    
    void buildSuffixArray() {
        int n = s.size();
        vector<int> c(n), c_new(n);
        
        // 初始化
        for (int i = 0; i < n; i++) {
            c[i] = s[i];
        }
        
        // 计数排序
        countingSort(c);
        
        for (int len = 1; len < n; len *= 2) {
            // 按第二关键字排序
            for (int i = 0; i < n; i++) {
                int j = (sa[i] - len + n) % n;
                // 处理排序逻辑
            }
            
            // 按第一关键字排序
            countingSort(c);
            
            // 更新rank数组
            c_new[sa[0]] = 0;
            for (int i = 1; i < n; i++) {
                pair<int,int> prev = {c[sa[i-1]], c[(sa[i-1] + len) % n]};
                pair<int,int> curr = {c[sa[i]], c[(sa[i] + len) % n]};
                c_new[sa[i]] = c_new[sa[i-1]] + (prev != curr);
            }
            c = c_new;
        }
        
        // 构建rank数组
        rank.resize(n);
        for (int i = 0; i < n; i++) {
            rank[sa[i]] = i;
        }
    }
    
    void buildLCP() {
        int n = s.size();
        lcp.resize(n);
        
        for (int i = 0, k = 0; i < n; i++) {
            if (rank[i] == n - 1) {
                k = 0;
                continue;
            }
            
            int j = sa[rank[i] + 1];
            while (i + k < n && j + k < n && s[i + k] == s[j + k]) {
                k++;
            }
            lcp[rank[i]] = k;
            if (k > 0) k--;
        }
    }
    
private:
    void countingSort(vector<int>& c) {
        int n = s.size();
        vector<int> cnt(max(256, n), 0);
        
        for (int i = 0; i < n; i++) {
            cnt[c[i]]++;
        }
        
        for (int i = 1; i < cnt.size(); i++) {
            cnt[i] += cnt[i - 1];
        }
        
        vector<int> sa_new(n);
        for (int i = n - 1; i >= 0; i--) {
            sa_new[--cnt[c[sa[i]]]] = sa[i];
        }
        sa = sa_new;
    }
};
```

### 8.4 Z算法（扩展KMP）

**用途**：在线性时间内计算字符串与其所有后缀的最长公共前缀

```cpp
vector<int> z_function(string s) {
    int n = s.size();
    vector<int> z(n);
    
    for (int i = 1, l = 0, r = 0; i < n; i++) {
        if (i <= r) {
            z[i] = min(r - i + 1, z[i - l]);
        }
        
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
        
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
    
    return z;
}

// 应用：字符串匹配
vector<int> search(string text, string pattern) {
    string combined = pattern + "$" + text;
    vector<int> z = z_function(combined);
    vector<int> result;
    
    for (int i = pattern.size() + 1; i < combined.size(); i++) {
        if (z[i] == pattern.size()) {
            result.push_back(i - pattern.size() - 1);
        }
    }
    
    return result;
}
```

---

## 9. 题型识别与算法选择

### 9.1 题型识别流程图

```
字符串问题
    ├── 看到"匹配"、"查找"、"包含" 
    │   ├── 已知模式串 → KMP/Boyer-Moore
    │   ├── 未知模式，需要发现 → 滑动窗口/双指针
    │   └── 多模式匹配 → Trie/AC自动机
    │
    ├── 看到"回文" 
    │   ├── 验证回文 → 双指针
    │   ├── 最长回文子串 → 中心扩展/Manacher/DP
    │   └── 回文分割 → DP + 回溯
    │
    ├── 看到"最长"、"最短"、"最多"、"最少"
    │   ├── 连续子串问题 → 滑动窗口
    │   ├── 子序列问题 → DP
    │   └── 路径/操作数问题 → DP
    │
    ├── 看到"重复"、"周期"
    │   ├── 检测重复模式 → KMP前缀函数
    │   ├── 去除重复 → 双指针/哈希表
    │   └── 统计重复 → 哈希表/数组
    │
    ├── 看到"连续"、"子数组"、"窗口"
    │   └── 滑动窗口
    │
    ├── 看到"变换"、"编辑"、"操作"
    │   └── DP（编辑距离类问题）
    │
    └── 看到"前缀"、"后缀"
        ├── 字典树相关 → Trie
        └── 公共前缀 → 分治/二分/Trie
```

### 9.2 关键词对应算法表

| 关键词 | 优先考虑算法 | 备选算法 |
|--------|-------------|----------|
| 回文 | 双指针、中心扩展 | DP、Manacher |
| 匹配、查找 | KMP | Boyer-Moore、暴力 |
| 最长子串 | 滑动窗口 | DP |
| 最长子序列 | DP | 贪心（特殊情况） |
| 重复、周期 | KMP前缀函数 | Z算法 |
| 编辑距离 | DP | - |
| 前缀匹配 | Trie | 哈希表 |
| 连续、窗口 | 滑动窗口 | 双指针 |

### 9.3 复杂度要求指导

| 数据规模 | 可接受复杂度 | 推荐算法 |
|---------|-------------|----------|
| n ≤ 100 | O(n³) | 暴力、简单DP |
| n ≤ 1000 | O(n²) | DP、双重循环 |
| n ≤ 10⁵ | O(n log n) | 排序、分治、二分 |
| n ≤ 10⁶ | O(n) | 双指针、滑动窗口、KMP |
| n ≤ 10⁷ | O(n) | 线性算法 |

### 9.4 算法选择决策树

```cpp
// 伪代码：算法选择逻辑
if (题目包含"回文") {
    if (只需验证) return 双指针();
    if (求最长回文子串) {
        if (n <= 1000) return DP();
        else return 中心扩展() || Manacher();
    }
}

if (题目包含"匹配" || "查找子串") {
    if (模式串长度 > 10 && 文本长度 > 10000) return KMP();
    else return 暴力匹配();
}

if (题目包含"最长" && "子串" && "条件") {
    return 滑动窗口();
}

if (题目包含"最长" && "子序列") {
    return DP();
}

if (题目包含"编辑" || "变换" || "操作数") {
    return DP();
}
```

---

## 10. 个人错误总结与改进

### 10.1 语法错误类

#### 错误1：数组类型声明错误
```cpp
// ❌ 错误写法
vector<int> temp[128];  // 创建了128个vector，不是128个int

// ✅ 正确写法
int temp[128];          // 创建128个int的数组
vector<int> temp(128);  // 或者用vector
```

**改进建议**：
- 明确数组vs向量的区别
- 静态数组：`int arr[SIZE]`
- 动态数组：`vector<int> arr(SIZE)`

#### 错误2：赋值运算符错误
```cpp
// ❌ 错误写法
if (s[i] = ' ')  // 这是赋值，不是比较

// ✅ 正确写法
if (s[i] == ' ') // 这是比较
```

**改进建议**：
- `=` 是赋值运算符
- `==` 是相等比较运算符
- 养成习惯：条件判断用 `==`

#### 错误3：语句缺少分号
```cpp
// ❌ 错误写法
left = temp[char1] + 1  // 缺少分号

// ✅ 正确写法
left = temp[char1] + 1;
```

### 10.2 逻辑错误类

#### 错误1：循环边界错误
```cpp
// ❌ 常犯错误
for (int i = 0; i < s.size() - 1; i++)  // 漏掉最后一个元素

// ✅ 正确写法
for (int i = 0; i < s.size(); i++)      // 遍历所有元素
```

**分析**：
- `s.size() - 1` 会导致最后一个元素被跳过
- 只有在确实不需要最后一个元素时才这样写

#### 错误2：返回值处理错误
```cpp
// ❌ 在removespace函数中
return s;  // 返回原字符串，包含无效部分

// ✅ 正确写法
return s.substr(0, slow);  // 只返回有效部分
```

**原理**：
- 原地修改后，原字符串可能包含无效的尾部
- 必须用 `substr()` 提取有效部分

#### 错误3：指针移动逻辑错误
```cpp
// ❌ expandAroundCenter函数中
while (left >= 0 && right < s.size()) {
    if (s[left] == s[right]) {
        len += 2;  // 语法错误：应该是 len += 2;
        left--;
        right++;
    }
    else return right - left - 1;  // 逻辑混乱
}
return len - 1;  // 不一致的返回逻辑
```

**问题**：
1. `len += 2` 语法错误
2. 混用了两种长度计算方法
3. 返回值不一致

**正确版本**：
```cpp
int expandAroundCenter(string s, int left, int right) {
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        left--;
        right++;
    }
    return right - left - 1;  // 统一用这个公式
}
```

### 10.3 算法理解错误类

#### 错误1：KMP前缀函数理解错误
```cpp
// 你之前求出 next = [0,0,1,2] 是正确的
// 但不理解为什么跳转时要连续使用next数组
```

**正确理解**：
- KMP的跳转是**递归的**
- `j = next[j-1]` 可能需要执行多次
- 每次跳转都是在寻找更短的匹配前缀

#### 错误2：滑动窗口模板应用错误
**问题**：对窗口收缩的时机理解不准确

**模板理解**：
```cpp
while (right < n) {
    // 扩大窗口：添加right元素
    
    while (窗口不满足条件) {
        // 收缩窗口：移除left元素
    }
    
    // 更新答案
}
```

### 10.4 调试技巧改进

#### 技巧1：添加调试输出
```cpp
// 在关键位置添加输出
cout << "i=" << i << ", len1=" << len1 << ", len2=" << len2 << endl;
cout << "maxLen=" << maxLen << ", start=" << start << endl;
```

#### 技巧2：手动跟踪小例子
**建议**：
- 用纸笔手动模拟算法执行
- 选择简单的测试用例（长度≤5）
- 逐步记录变量变化

#### 技巧3：单独测试函数
```cpp
// 将复杂函数分解，单独测试
int main() {
    string s = "bb";
    cout << expandAroundCenter(s, 0, 1) << endl;  // 应该输出2
    return 0;
}
```

### 10.5 代码风格改进建议

#### 建议1：变量命名一致性
```cpp
// ❌ 不一致
int len = 0;
len = max(maxLength, right - left + 1);  // maxLength未定义

// ✅ 一致
int maxLen = 0;
maxLen = max(maxLen, right - left + 1);
```

#### 建议2：适当的注释
```cpp
int expandAroundCenter(string s, int left, int right) {
    // 从中心向两边扩展，寻找最长回文
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        left--;
        right++;
    }
    // 返回回文长度
    return right - left - 1;
}
```

#### 建议3：边界条件检查
```cpp
if (s.empty()) return "";  // 处理空字符串
if (s.size() == 1) return s;  // 处理单字符
```

---

## 11. 经典题目分类汇总

### 11.1 双指针类题目

#### 11.1.1 基础双指针
| 题目 | 难度 | 关键点 | 模板 |
|------|------|--------|------|
| 344. 反转字符串 | 简单 | 对撞指针 | 基础模板 |
| 541. 反转字符串II | 简单 | 分段处理 | 双指针+逻辑 |
| 151. 反转字符串中的单词 | 中等 | 去空格+反转 | 快慢指针+双指针 |

**通用模板**：
```cpp
// 对撞指针模板
void reverseString(string& s, int start, int end) {
    while (start < end) {
        swap(s[start], s[end]);
        start++;
        end--;
    }
}
```

#### 11.1.2 回文检测类
| 题目 | 难度 | 关键点 | 算法 |
|------|------|--------|------|
| 125. 验证回文串 | 简单 | 忽略非字母数字 | 双指针 |
| 680. 验证回文串II | 简单 | 允许删除一个字符 | 双指针+递归 |
| 5. 最长回文子串 | 中等 | 中心扩展 | 中心扩展法 |

**中心扩展模板**：
```cpp
int expandAroundCenter(string s, int left, int right) {
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        left--;
        right++;
    }
    return right - left - 1;
}
```

### 11.2 滑动窗口类题目

#### 11.2.1 无重复字符类
| 题目 | 难度 | 关键点 | 数据结构 |
|------|------|--------|----------|
| 3. 无重复字符的最长子串 | 中等 | 字符去重 | HashSet/数组 |
| 159. 至多包含两个不同字符的最长子串 | 困难 | 字符计数 | HashMap |
| 340. 至多包含K个不同字符的最长子串 | 困难 | 字符计数 | HashMap |

**无重复字符模板**：
```cpp
int lengthOfLongestSubstring(string s) {
    unordered_set<char> window;
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < s.size(); right++) {
        while (window.count(s[right])) {
            window.erase(s[left++]);
        }
        window.insert(s[right]);
        maxLen = max(maxLen, right - left + 1);
    }
    return maxLen;
}
```

#### 11.2.2 子串覆盖类
| 题目 | 难度 | 关键点 | 技巧 |
|------|------|--------|------|
| 76. 最小覆盖子串 | 困难 | 字符计数匹配 | 两个HashMap |
| 567. 字符串的排列 | 中等 | 排列匹配 | 固定窗口 |
| 438. 找到字符串中所有字母异位词 | 中等 | 异位词检测 | 固定窗口 |

**最小覆盖子串模板**：
```cpp
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0;  // 满足条件的字符种类数
    int start = 0, len = INT_MAX;
    
    while (right < s.size()) {
        char c = s[right];
        right++;
        
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c]) {
                valid++;
            }
        }
        
        while (valid == need.size()) {
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            
            char d = s[left];
            left++;
            if (need.count(d)) {
                if (window[d] == need[d]) {
                    valid--;
                }
                window[d]--;
            }
        }
    }
    
    return len == INT_MAX ? "" : s.substr(start, len);
}
```

### 11.3 KMP类题目

#### 11.3.1 字符串匹配类
| 题目 | 难度 | 关键点 | 应用 |
|------|------|--------|------|
| 28. 找出字符串中第一个匹配项的下标 | 简单 | 基础KMP | 直接应用 |
| 459. 重复的子字符串 | 简单 | 前缀函数性质 | 数学推导 |
| 1392. 最长快乐前缀 | 困难 | 前缀后缀匹配 | 前缀函数 |

**KMP完整模板**：
```cpp
class KMP {
private:
    vector<int> computePrefix(string pattern) {
        int m = pattern.size();
        vector<int> prefix(m, 0);
        
        for (int i = 1; i < m; i++) {
            int j = prefix[i - 1];
            while (j > 0 && pattern[i] != pattern[j]) {
                j = prefix[j - 1];
            }
            if (pattern[i] == pattern[j]) {
                j++;
            }
            prefix[i] = j;
        }
        return prefix;
    }
    
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        
        vector<int> prefix = computePrefix(needle);
        int n = haystack.size(), m = needle.size();
        int j = 0;
        
        for (int i = 0; i < n; i++) {
            while (j > 0 && haystack[i] != needle[j]) {
                j = prefix[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == m) {
                return i - m + 1;
            }
        }
        return -1;
    }
    
    bool repeatedSubstringPattern(string s) {
        vector<int> prefix = computePrefix(s);
        int n = s.size();
        return prefix[n - 1] != 0 && n % (n - prefix[n - 1]) == 0;
    }
};
```

### 11.4 动态规划类题目

#### 11.4.1 子序列DP
| 题目 | 难度 | 状态定义 | 转移方程 |
|------|------|----------|----------|
| 1143. 最长公共子序列 | 中等 | dp[i][j] = LCS长度 | 匹配+1 或 max(dp[i-1][j], dp[i][j-1]) |
| 516. 最长回文子序列 | 中等 | dp[i][j] = 区间回文长度 | s[i]==s[j] ? dp[i+1][j-1]+2 : max(...) |
| 583. 两个字符串的删除操作 | 中等 | dp[i][j] = 最少删除数 | 基于LCS |

**LCS标准模板**：
```cpp
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

#### 11.4.2 编辑距离类
| 题目 | 难度 | 操作类型 | 特点 |
|------|------|----------|------|
| 72. 编辑距离 | 困难 | 增删改 | 经典DP |
| 161. 相隔为1的编辑距离 | 中等 | 仅一次操作 | 特殊情况 |
| 712. 两个字符串的最小ASCII删除和 | 中等 | 带权重删除 | 变种DP |

**编辑距离标准模板**：
```cpp
int minDistance(string word1, string word2) {
    int m = word1.size(), n = word2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));
    
    // 边界条件
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + min({
                    dp[i - 1][j],     // 删除
                    dp[i][j - 1],     // 插入
                    dp[i - 1][j - 1]  // 替换
                });
            }
        }
    }
    return dp[m][n];
}
```

### 11.5 字符串变换类题目

#### 11.5.1 反转和重排
| 题目 | 难度 | 关键技巧 | 算法 |
|------|------|----------|------|
| 344. 反转字符串 | 简单 | 双指针 | O(1)空间 |
| 541. 反转字符串II | 简单 | 分段处理 | 双指针变种 |
| 151. 反转字符串中的单词 | 中等 | 三步反转 | 双指针+预处理 |
| 557. 反转字符串中的单词III | 简单 | 单词内反转 | 双指针 |

**三步反转法模板（翻转单词）**：
```cpp
string reverseWords(string s) {
    // 步骤1: 去除多余空格
    s = removeExtraSpaces(s);
    
    // 步骤2: 反转整个字符串
    reverse(s.begin(), s.end());
    
    // 步骤3: 反转每个单词
    int start = 0;
    for (int i = 0; i <= s.size(); i++) {
        if (i == s.size() || s[i] == ' ') {
            reverse(s.begin() + start, s.begin() + i);
            start = i + 1;
        }
    }
    
    return s;
}
```

#### 11.5.2 字符替换类
| 题目 | 难度 | 处理方式 | 技巧 |
|------|------|----------|------|
| 替换数字 | 简单 | 遍历替换 | 字符判断 |
| 389. 找不同 | 简单 | 字符统计 | 异或/哈希 |
| 383. 赎金信 | 简单 | 字符计数 | 数组计数 |

**字符替换通用模板**：
```cpp
string replacePattern(string s, string pattern, string replacement) {
    string result = "";
    for (char c : s) {
        if (shouldReplace(c)) {
            result += replacement;
        } else {
            result += c;
        }
    }
    return result;
}
```

### 11.6 高级字符串算法题目

#### 11.6.1 Manacher算法题目
| 题目 | 难度 | 关键点 | 优势 |
|------|------|--------|------|
| 5. 最长回文子串 | 中等 | O(n)时间复杂度 | 大数据量 |
| 214. 最短回文串 | 困难 | 前缀回文 | 结合KMP |

#### 11.6.2 字典树题目
| 题目 | 难度 | 应用场景 | 特点 |
|------|------|----------|------|
| 208. 实现Trie | 中等 | 前缀匹配 | 基础结构 |
| 211. 添加与搜索单词 | 中等 | 通配符匹配 | DFS+Trie |
| 212. 单词搜索II | 困难 | 多单词搜索 | Trie+回溯 |

### 11.7 题目练习顺序建议

#### 阶段1：基础双指针（1-2天）
```
344. 反转字符串 → 541. 反转字符串II → 151. 反转字符串中的单词
125. 验证回文串 → 5. 最长回文子串
```

#### 阶段2：滑动窗口（2-3天）
```
3. 无重复字符的最长子串 → 76. 最小覆盖子串
209. 长度最小的子数组 → 438. 找到字符串中所有字母异位词
```

#### 阶段3：KMP算法（2-3天）
```
28. 找出字符串中第一个匹配项的下标 → 459. 重复的子字符串
理解前缀函数 → 练习手算next数组
```

#### 阶段4：动态规划（3-4天）
```
1143. 最长公共子序列 → 72. 编辑距离
516. 最长回文子序列 → 5. 最长回文子串(DP版)
```

#### 阶段5：综合提升（3-5天）
```
复习所有模板 → 混合题目练习 → 竞赛题目
```

---

## 12. 复习检查清单

### 12.1 核心概念检查

#### ✅ 双指针技术
- [ ] 能手写对撞指针模板
- [ ] 理解快慢指针的应用场景
- [ ] 掌握中心扩展的变种写法
- [ ] 知道何时使用双指针优化

#### ✅ 滑动窗口算法
- [ ] 能默写滑动窗口通用模板
- [ ] 区分固定窗口和可变窗口
- [ ] 理解窗口收缩的时机
- [ ] 掌握窗口状态的维护方法

#### ✅ KMP算法
- [ ] 能手算简单字符串的next数组
- [ ] 理解前缀函数的物理意义
- [ ] 掌握KMP匹配过程的跳转逻辑
- [ ] 知道KMP在重复子串检测中的应用

#### ✅ 动态规划
- [ ] 掌握LCS问题的状态定义和转移
- [ ] 理解编辑距离的三种操作
- [ ] 能写出回文相关的DP状态方程
- [ ] 了解空间优化的技巧

### 12.2 编程技能检查

#### ✅ C++语法掌握
- [ ] 正确使用 `==` 和 `=`
- [ ] 理解数组和vector的区别
- [ ] 掌握字符串基本操作（substr, find等）
- [ ] 熟练使用STL容器（set, map, vector）

#### ✅ 算法实现能力
- [ ] 能快速写出暴力解法
- [ ] 掌握边界条件的处理
- [ ] 养成添加调试输出的习惯
- [ ] 能够手动跟踪算法执行过程

#### ✅ 代码调试技能
- [ ] 能识别常见的逻辑错误
- [ ] 掌握用小例子验证算法的方法
- [ ] 知道如何定位边界条件错误
- [ ] 养成code review的习惯

### 12.3 题型识别能力检查

#### ✅ 关键词识别
- [ ] 看到"回文"立即想到双指针/中心扩展
- [ ] 看到"匹配"立即想到KMP
- [ ] 看到"最长子串+条件"立即想到滑动窗口
- [ ] 看到"最长子序列"立即想到DP

#### ✅ 复杂度分析
- [ ] 能估算不同算法的时间复杂度
- [ ] 根据数据规模选择合适算法
- [ ] 理解空间复杂度的权衡
- [ ] 知道何时需要空间优化

### 12.4 模板熟练度检查

#### ✅ 必背模板清单

**双指针模板**：
```cpp
// 对撞指针
void twoPointers(string& s, int start, int end) {
    while (start < end) {
        // 处理逻辑
        start++;
        end--;
    }
}

// 中心扩展
int expandAroundCenter(string s, int left, int right) {
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        left--;
        right++;
    }
    return right - left - 1;
}
```

**滑动窗口模板**：
```cpp
int slidingWindow(string s) {
    int left = 0, result = 0;
    unordered_map<char, int> window;
    
    for (int right = 0; right < s.size(); right++) {
        // 扩大窗口
        window[s[right]]++;
        
        // 收缩窗口
        while (窗口需要收缩) {
            // 更新结果
            result = max(result, right - left + 1);
            window[s[left]]--;
            left++;
        }
    }
    return result;
}
```

**KMP模板**：
```cpp
vector<int> computePrefix(string pattern) {
    int m = pattern.size();
    vector<int> prefix(m, 0);
    
    for (int i = 1; i < m; i++) {
        int j = prefix[i - 1];
        while (j > 0 && pattern[i] != pattern[j]) {
            j = prefix[j - 1];
        }
        if (pattern[i] == pattern[j]) {
            j++;
        }
        prefix[i] = j;
    }
    return prefix;
}

int KMPSearch(string text, string pattern) {
    vector<int> prefix = computePrefix(pattern);
    int j = 0;
    
    for (int i = 0; i < text.size(); i++) {
        while (j > 0 && text[i] != pattern[j]) {
            j = prefix[j - 1];
        }
        if (text[i] == pattern[j]) {
            j++;
        }
        if (j == pattern.size()) {
            return i - pattern.size() + 1;
        }
    }
    return -1;
}
```

**DP模板**：
```cpp
// LCS模板
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}

// 编辑距离模板
int minDistance(string word1, string word2) {
    int m = word1.size(), n = word2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));
    
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});
            }
        }
    }
    return dp[m][n];
}
```

### 12.5 实战能力检查

#### ✅ 快速解题流程
1. **读题**：提取关键词，识别题型
2. **分析**：确定算法，估算复杂度
3. **编码**：套用模板，处理细节
4. **测试**：验证样例，检查边界
5. **优化**：时间空间优化，代码简化

#### ✅ 常见陷阱避免
- [ ] 数组越界检查
- [ ] 空字符串处理
- [ ] 整数溢出考虑
- [ ] 指针空值检查
- [ ] 循环条件设置

### 12.6 持续提升计划

#### 短期目标（1个月内）
- [ ] 熟练掌握所有基础模板
- [ ] 能快速识别80%的字符串题型
- [ ] 独立完成中等难度题目
- [ ] 建立个人题库和错题集

#### 中期目标（3个月内）
- [ ] 掌握高级字符串算法（Manacher, Trie等）
- [ ] 能解决大部分困难题目
- [ ] 参加在线竞赛获得好成绩
- [ ] 总结更多算法模板和技巧

#### 长期目标（半年以上）
- [ ] 成为字符串算法专家
- [ ] 能创造性地组合多种算法
- [ ] 指导他人学习字符串算法
- [ ] 在实际项目中应用算法优化

---

## 📚 学习资源推荐

### 在线平台
- **LeetCode**：题目练习，按标签刷题
- **洛谷**：基础算法学习，中文题目
- **Codeforces**：竞赛练习，提高实战能力

### 参考书籍
- 《算法竞赛进阶指南》- 字符串专题
- 《算法导论》- 理论基础深入
- 《编程珠玑》- 实践技巧提升

### 学习建议
1. **理论与实践结合**：不仅要理解算法原理，更要多动手实现
2. **循序渐进**：从简单题目开始，逐步增加难度
3. **总结归纳**：定期回顾，建立知识体系
4. **讨论交流**：与他人分享学习心得，答疑解惑
5. **持续练习**：保持手感，定期复习模板

---

## 🎯 结语

通过今天的学习和总结，你已经从一个字符串算法的初学者成长为具备系统知识的学习者。这份笔记涵盖了字符串算法的方方面面，从基础的双指针到高级的KMP算法，从经典题目到错误总结，应该能够成为你后续学习和复习的重要参考资料。

记住，算法学习是一个持续的过程，需要不断地练习和思考。保持对新题目的敏感性，不断总结新的模板和技巧，相信你在字符串算法领域会越来越精通！

**最后的建议**：
- 每周至少练习3-5道字符串相关题目
- 定期回顾这份笔记，特别是错误总结部分
- 遇到新的题型及时补充到个人题库中
- 与其他算法领域结合学习，提升综合能力

加油！你的算法之路才刚刚开始！🚀