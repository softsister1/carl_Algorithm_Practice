# 嵌入式开发者排序算法完全指南

## 目录

1. [排序算法概述](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#排序算法概述)
2. [插入排序 (Insertion Sort)](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#插入排序-insertion-sort)
3. [选择排序 (Selection Sort)](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#选择排序-selection-sort)
4. [冒泡排序 (Bubble Sort)](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#冒泡排序-bubble-sort)
5. [快速排序 (Quick Sort)](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#快速排序-quick-sort)
6. [归并排序 (Merge Sort)](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#归并排序-merge-sort)
7. [堆排序 (Heap Sort)](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#堆排序-heap-sort)
8. [嵌入式环境下的排序算法选择](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#嵌入式环境下的排序算法选择)
9. [面试常见问题](https://claude.ai/chat/a3b2c093-9d3a-42fd-b5a7-14e9ad7629c7#面试常见问题)

------

## 排序算法概述

### 什么是排序算法？

排序算法是将一组数据按照特定顺序（通常是升序或降序）重新排列的算法。在嵌入式系统中，排序算法的选择直接影响系统的性能、内存使用和实时性。

### 排序算法的分类

#### 按稳定性分类

- **稳定排序**：相等元素的相对位置不变（插入排序、归并排序、冒泡排序）
- **不稳定排序**：相等元素的相对位置可能改变（选择排序、快速排序、堆排序）

#### 按存储方式分类

- **内部排序**：数据全部在内存中进行排序
- **外部排序**：数据量大，需要借助外存进行排序

#### 按比较方式分类

- **比较排序**：通过比较元素大小来排序
- **非比较排序**：不通过比较，如计数排序、基数排序

### 复杂度分析基础

- **时间复杂度**：算法执行时间与输入规模的关系
- **空间复杂度**：算法所需额外空间与输入规模的关系
- **最好情况**：输入数据已经有序
- **最坏情况**：输入数据完全逆序
- **平均情况**：随机输入数据的期望性能

------

## 插入排序 (Insertion Sort)

### 算法思想

插入排序的核心思想类似于整理扑克牌：将待排序的元素逐个插入到已排序的序列中的正确位置。

### 算法步骤

1. 从第二个元素开始，将其作为待插入元素
2. 在已排序的序列中从后向前比较，找到合适的插入位置
3. 将大于待插入元素的元素依次后移
4. 将待插入元素插入到正确位置
5. 重复步骤1-4，直到所有元素都被处理

### C++实现

```cpp
#include <iostream>
#include <vector>
using namespace std;

/**
 * 插入排序 - 基础版本
 * @param arr 待排序数组
 * @param n 数组长度
 */
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];  // 待插入元素
        int j = i - 1;     // 已排序序列的最后一个元素索引
        
        // 向前查找插入位置，同时后移元素
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];  // 元素后移
            j--;
        }
        arr[j + 1] = key;  // 插入元素
    }
}

/**
 * 插入排序 - 模板版本（支持任意类型）
 */
template<typename T>
void insertionSort(vector<T>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        T key = arr[i];
        int j = i - 1;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

/**
 * 插入排序 - 优化版本（二分查找插入位置）
 */
void binaryInsertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int left = 0, right = i - 1;
        
        // 二分查找插入位置
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] > key) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 移动元素并插入
        for (int j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j];
        }
        arr[left] = key;
    }
}

// 测试函数
void testInsertionSort() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "原数组: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    insertionSort(arr, n);
    
    cout << "排序后: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

### 复杂度分析

| 情况     | 时间复杂度 | 说明                               |
| -------- | ---------- | ---------------------------------- |
| 最好情况 | O(n)       | 数组已经有序，每个元素只需比较一次 |
| 最坏情况 | O(n²)      | 数组完全逆序，需要最多的比较和移动 |
| 平均情况 | O(n²)      | 随机数组的期望性能                 |

**空间复杂度**：O(1) - 原地排序，只需要常数级额外空间

### 嵌入式应用注意点

#### 优点

1. **实现简单**：代码量少，易于理解和调试
2. **空间效率高**：原地排序，不需要额外内存
3. **对小数据集高效**：n < 50时性能优秀
4. **稳定排序**：相等元素相对位置不变
5. **自适应**：对部分有序数组效率很高
6. **在线算法**：可以在接收数据时进行排序

#### 嵌入式优化技巧

```cpp
// 针对嵌入式的优化版本
void embeddedInsertionSort(int* arr, int n) {
    register int i, j, key;  // 使用寄存器变量
    
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        
        // 减少数组访问次数
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            --j;  // 前缀递减更高效
        }
        arr[j + 1] = key;
    }
}
```

------

## 选择排序 (Selection Sort)

### 算法思想

选择排序的思想是：每次从未排序的部分中选出最小（或最大）的元素，将其放到已排序部分的末尾。

### 算法步骤

1. 在未排序序列中找到最小元素
2. 将其与第一个元素交换位置
3. 在剩余未排序序列中找到最小元素
4. 将其与第二个元素交换位置
5. 重复此过程直到整个序列有序

### C++实现 

```cpp
#include <iostream>
#include <algorithm>  // for swap
using namespace std;

/**
 * 选择排序 - 基础版本
 */
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;  // 假设第i个元素是最小的
        
        // 在未排序部分找到真正的最小元素
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // 如果最小元素不是当前位置，则交换
        if (minIdx != i) {
            swap(arr[i], arr[minIdx]);
        }
    }
}

/**
 * 选择排序 - 双向选择优化版本
 * 每次同时找到最大值和最小值，放在两端
 */
void bidirectionalSelectionSort(int arr[], int n) {
    int left = 0, right = n - 1;
    
    while (left < right) {
        int minIdx = left, maxIdx = right;
        
        // 同时找到最小值和最大值的索引
        for (int i = left; i <= right; i++) {
            if (arr[i] < arr[minIdx]) {
                minIdx = i;
            }
            if (arr[i] > arr[maxIdx]) {
                maxIdx = i;
            }
        }
        
        // 处理边界情况：如果最大值在left位置
        if (maxIdx == left) {
            maxIdx = minIdx;
        }
        
        // 将最小值放到左边
        if (minIdx != left) {
            swap(arr[left], arr[minIdx]);
        }
        
        // 将最大值放到右边
        if (maxIdx != right) {
            swap(arr[right], arr[maxIdx]);
        }
        
        left++;
        right--;
    }
}

/**
 * 选择排序 - 模板版本
 */
template<typename T, typename Compare = less<T>>
void selectionSort(T arr[], int n, Compare comp = Compare()) {
    for (int i = 0; i < n - 1; i++) {
        int selectedIdx = i;
        
        for (int j = i + 1; j < n; j++) {
            if (comp(arr[j], arr[selectedIdx])) {
                selectedIdx = j;
            }
        }
        
        if (selectedIdx != i) {
            swap(arr[i], arr[selectedIdx]);
        }
    }
}

// 测试函数
void testSelectionSort() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "原数组: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    selectionSort(arr, n);
    
    cout << "排序后: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

### 复杂度分析

| 情况     | 时间复杂度 | 说明                             |
| -------- | ---------- | -------------------------------- |
| 最好情况 | O(n²)      | 即使数组已有序，仍需进行所有比较 |
| 最坏情况 | O(n²)      | 与最好情况相同                   |
| 平均情况 | O(n²)      | 时间复杂度稳定                   |

**空间复杂度**：O(1) - 原地排序

### 嵌入式应用注意点

#### 优点

1. **交换次数少**：最多进行n-1次交换，适合交换成本高的场景
2. **空间效率高**：原地排序
3. **实现简单**：代码逻辑直观
4. **性能稳定**：时间复杂度不受数据分布影响

#### 缺点

1. **不是稳定排序**：相等元素的相对位置可能改变
2. **不是自适应的**：对已排序数据没有优化

#### 嵌入式优化技巧

```cpp
// 针对嵌入式的优化版本
void embeddedSelectionSort(int* arr, int n) {
    register int i, j, minIdx;
    register int temp;
    
    for (i = 0; i < n - 1; i++) {
        minIdx = i;
        
        // 展开循环优化（适用于已知小数组大小）
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // 避免不必要的交换
        if (minIdx != i) {
            temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
        }
    }
}
```

------

## 冒泡排序 (Bubble Sort)

### 算法思想

冒泡排序通过重复遍历待排序数组，比较相邻元素并交换位置，使较大的元素逐渐"冒泡"到数组的末尾。

### 算法步骤

1. 比较相邻的两个元素
2. 如果左边的元素大于右边的元素，则交换它们
3. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对
4. 重复步骤1-3，每次处理的元素个数减一
5. 持续每次处理直到没有任何一对数字需要比较

### C++实现

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

/**
 * 冒泡排序 - 基础版本
 */
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        // 每轮比较后，最大的元素会"冒泡"到末尾
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

/**
 * 冒泡排序 - 优化版本1（提前终止）
 * 如果某轮没有发生交换，说明已经有序
 */
void optimizedBubbleSort1(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;  // 标记是否发生交换
        
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        
        // 如果没有交换发生，数组已经有序
        if (!swapped) {
            break;
        }
    }
}

/**
 * 冒泡排序 - 优化版本2（记录最后交换位置）
 * 记录最后一次交换的位置，该位置之后的元素已经有序
 */
void optimizedBubbleSort2(int arr[], int n) {
    int lastSwapPos = n - 1;  // 最后交换位置
    
    while (lastSwapPos > 0) {
        int newLastSwapPos = 0;
        
        for (int j = 0; j < lastSwapPos; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                newLastSwapPos = j;  // 记录交换位置
            }
        }
        
        lastSwapPos = newLastSwapPos;
    }
}

/**
 * 鸡尾酒排序 - 双向冒泡排序
 * 交替从两个方向进行冒泡，可以更快地移动元素
 */
void cocktailSort(int arr[], int n) {
    int left = 0, right = n - 1;
    bool swapped = true;
    
    while (swapped && left < right) {
        swapped = false;
        
        // 从左到右冒泡
        for (int i = left; i < right; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr[i], arr[i + 1]);
                swapped = true;
            }
        }
        right--;
        
        if (!swapped) break;
        
        // 从右到左冒泡
        for (int i = right; i > left; i--) {
            if (arr[i] < arr[i - 1]) {
                swap(arr[i], arr[i - 1]);
                swapped = true;
            }
        }
        left++;
    }
}

// 测试函数
void testBubbleSort() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "原数组: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    optimizedBubbleSort1(arr, n);
    
    cout << "排序后: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

### 复杂度分析

| 情况     | 时间复杂度 | 说明                             |
| -------- | ---------- | -------------------------------- |
| 最好情况 | O(n)       | 数组已有序，优化版本只需一轮遍历 |
| 最坏情况 | O(n²)      | 数组完全逆序                     |
| 平均情况 | O(n²)      | 随机数组                         |

**空间复杂度**：O(1) - 原地排序

### 嵌入式应用注意点

#### 优点

1. **稳定排序**：相等元素相对位置不变
2. **空间效率高**：原地排序
3. **实现简单**：逻辑清晰，易于理解
4. **自适应性好**：对部分有序数组效率较高

#### 缺点

1. **效率较低**：平均和最坏情况都是O(n²)
2. **交换次数多**：不适合交换成本高的场景

#### 嵌入式优化技巧

```cpp
// 针对嵌入式的优化版本
void embeddedBubbleSort(int* arr, int n) {
    register int i, j;
    register int temp;
    register bool swapped;
    
    for (i = 0; i < n - 1; i++) {
        swapped = false;
        
        // 使用指针算术优化数组访问
        int* ptr = arr;
        for (j = 0; j < n - i - 1; j++, ptr++) {
            if (*ptr > *(ptr + 1)) {
                // 手动交换避免函数调用开销
                temp = *ptr;
                *ptr = *(ptr + 1);
                *(ptr + 1) = temp;
                swapped = true;
            }
        }
        
        if (!swapped) break;
    }
}
```

------

## 快速排序 (Quick Sort)

### 算法思想

快速排序采用分治的思想：选择一个基准元素（pivot），将数组分为两部分，左边的元素都小于基准，右边的元素都大于基准，然后递归地对左右两部分进行排序。

### 算法步骤

1. 选择数组中的一个元素作为基准（pivot）
2. 重新排列数组，所有比基准小的元素放在基准前面，比基准大的元素放在后面
3. 递归地对基准左边和右边的子数组进行排序

### C++实现

```cpp
#include <iostream>
#include <algorithm>
#include <random>
using namespace std;

/**
 * 快速排序 - 基础版本（Lomuto分区方案）
 */
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为基准
    int i = low - 1;        // 小于基准的元素的索引
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);  // 将基准放到正确位置
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);  // 分区索引
        
        quickSort(arr, low, pi - 1);   // 递归排序左半部分
        quickSort(arr, pi + 1, high);  // 递归排序右半部分
    }
}

/**
 * 快速排序 - Hoare分区方案（更高效）
 */
int hoarePartition(int arr[], int low, int high) {
    int pivot = arr[low];  // 选择第一个元素作为基准
    int i = low - 1, j = high + 1;
    
    while (true) {
        do { i++; } while (arr[i] < pivot);
        do { j--; } while (arr[j] > pivot);
        
        if (i >= j) return j;
        
        swap(arr[i], arr[j]);
    }
}

void hoareQuickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = hoarePartition(arr, low, high);
        hoareQuickSort(arr, low, pi);
        hoareQuickSort(arr, pi + 1, high);
    }
}

/**
 * 快速排序 - 随机化版本（避免最坏情况）
 */
int randomizedPartition(int arr[], int low, int high) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dis(low, high);
    
    int randomIndex = dis(gen);
    swap(arr[randomIndex], arr[high]);  // 将随机元素作为基准
    
    return partition(arr, low, high);
}

void randomizedQuickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = randomizedPartition(arr, low, high);
        randomizedQuickSort(arr, low, pi - 1);
        randomizedQuickSort(arr, pi + 1, high);
    }
}

/**
 * 三路快排 - 处理重复元素的优化版本
 */
void threeWayQuickSort(int arr[], int low, int high) {
    if (high <= low) return;
    
    int lt = low, gt = high;
    int pivot = arr[low];
    int i = low + 1;
    
    while (i <= gt) {
        if (arr[i] < pivot) {
            swap(arr[lt++], arr[i++]);
        } else if (arr[i] > pivot) {
            swap(arr[i], arr[gt--]);
        } else {
            i++;
        }
    }
    
    threeWayQuickSort(arr, low, lt - 1);
    threeWayQuickSort(arr, gt + 1, high);
}

/**
 * 迭代版快速排序 - 避免递归栈溢出
 */
#include <stack>
void iterativeQuickSort(int arr[], int low, int high) {
    stack<pair<int, int>> stk;
    stk.push({low, high});
    
    while (!stk.empty()) {
        auto [l, h] = stk.top();
        stk.pop();
        
        if (l < h) {
            int pi = partition(arr, l, h);
            stk.push({l, pi - 1});
            stk.push({pi + 1, h});
        }
    }
}

/**
 * 混合排序 - 小数组使用插入排序优化
 */
const int INSERTION_SORT_THRESHOLD = 10;

void hybridQuickSort(int arr[], int low, int high) {
    if (high - low <= INSERTION_SORT_THRESHOLD) {
        // 对小数组使用插入排序
        for (int i = low + 1; i <= high; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= low && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    } else {
        int pi = partition(arr, low, high);
        hybridQuickSort(arr, low, pi - 1);
        hybridQuickSort(arr, pi + 1, high);
    }
}

// 测试函数
void testQuickSort() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "原数组: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    quickSort(arr, 0, n - 1);
    
    cout << "排序后: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

### 复杂度分析

| 情况     | 时间复杂度 | 说明                             |
| -------- | ---------- | -------------------------------- |
| 最好情况 | O(n log n) | 每次分区都能均匀分割数组         |
| 最坏情况 | O(n²)      | 每次选择的基准都是最小或最大元素 |
| 平均情况 | O(n log n) | 随机数组的期望性能               |

**空间复杂度**：

- 最好/平均情况：O(log n) - 递归栈深度
- 最坏情况：O(n) - 递归栈深度

### 嵌入式应用注意点

#### 优点

1. **平均性能优秀**：O(n log n)的平均时间复杂度
2. **原地排序**：不需要额外的数组空间
3. **缓存友好**：局部性好，适合现代处理器

#### 缺点

1. **不稳定排序**：相等元素的相对位置可能改变
2. **最坏情况性能差**：O(n²)
3. **递归深度**：可能导致栈溢出

#### 嵌入式优化技巧

```cpp
// 针对嵌入式的优化版本
const int STACK_SIZE = 32;  // 限制栈大小

void embeddedQuickSort(int* arr, int n) {
    if (n <= 1) return;
    
    // 使用固定大小的栈避免动态内存分配
    struct Range { int low, high; };
    Range stack[STACK_SIZE];
    int stackTop = -1;
    
    stack[++stackTop] = {0, n - 1};
    
    while (stackTop >= 0) {
        Range curr = stack[stackTop--];
        
        if (curr.low < curr.high) {
            // 小数组使用插入排序
            if (curr.high - curr.low < 10) {
                for (int i = curr.low + 1; i <= curr.high; i++) {
                    int key = arr[i];
                    int j = i - 1;
                    while (j >= curr.low && arr[j] > key) {
                        arr[j + 1] = arr[j];
                        j--;
                    }
                    arr[j + 1] = key;
                }
            } else {
                int pi = partition(arr, curr.low, curr.high);
                
                // 先处理较小的子数组，减少栈使用
                if (pi - curr.low < curr.high - pi) {
                    if (stackTop < STACK_SIZE - 1) {
                        stack[++stackTop] = {curr.low, pi - 1};
                    }
                    if (stackTop < STACK_SIZE - 1) {
                        stack[++stackTop] = {pi + 1, curr.high};
                    }
                } else {
                    if (stackTop < STACK_SIZE - 1) {
                        stack[++stackTop] = {pi + 1, curr.high};
                    }
                    if (stackTop < STACK_SIZE - 1) {
                        stack[++stackTop] = {curr.low, pi - 1};
                    }
                }
            }
        }
    }
}

// 尾递归优化版本
void tailRecursiveQuickSort(int arr[], int low, int high) {
    while (low < high) {
        int pi = partition(arr, low, high);
        
        // 对较小的部分递归，较大的部分用循环
        if (pi - low < high - pi) {
            tailRecursiveQuickSort(arr, low, pi - 1);
            low = pi + 1;  // 尾递归优化
        } else {
            tailRecursiveQuickSort(arr, pi + 1, high);
            high = pi - 1;  // 尾递归优化
        }
    }
}
```

------

## 归并排序 (Merge Sort)

### 算法思想

归并排序基于分治法：将数组分成两半，分别递归排序，然后将结果合并成一个有序数组。它是一种稳定的排序算法，保证O(n log n)的时间复杂度。

### 算法步骤

1. **分割**：将数组从中间分成两个子数组
2. **递归**：递归地对两个子数组进行排序
3. **合并**：将两个已排序的子数组合并成一个有序数组

### C++实现

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

/**
 * 合并两个已排序的子数组
 * arr[left...mid] 和 arr[mid+1...right] 都已排序
 */
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左子数组大小
    int n2 = right - mid;     // 右子数组大小
    
    // 创建临时数组
    int* leftArr = new int[n1];
    int* rightArr = new int[n2];
    
    // 复制数据到临时数组
    for (int i = 0; i < n1; i++) {
        leftArr[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        rightArr[j] = arr[mid + 1 + j];
    }
    
    // 合并临时数组回到原数组
    int i = 0, j = 0, k = left;
    
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }
    
    // 复制剩余元素
    while (i < n1) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }
    
    while (j < n2) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
    
    // 释放临时数组
    delete[] leftArr;
    delete[] rightArr;
}

/**
 * 归并排序主函数
 */
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;  // 避免溢出
        
        mergeSort(arr, left, mid);        // 排序左半部分
        mergeSort(arr, mid + 1, right);   // 排序右半部分
        merge(arr, left, mid, right);     // 合并两部分
    }
}

/**
 * 归并排序 - 优化版本（使用预分配的辅助数组）
 */
void optimizedMerge(int arr[], int left, int mid, int right, int temp[]) {
    int i = left, j = mid + 1, k = left;
    
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    
    // 将临时数组复制回原数组
    for (i = left; i <= right; i++) {
        arr[i] = temp[i];
    }
}

void optimizedMergeSort(int arr[], int left, int right, int temp[]) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        optimizedMergeSort(arr, left, mid, temp);
        optimizedMergeSort(arr, mid + 1, right, temp);
        optimizedMerge(arr, left, mid, right, temp);
    }
}

// 包装函数
void optimizedMergeSort(int arr[], int n) {
    int* temp = new int[n];
    optimizedMergeSort(arr, 0, n - 1, temp);
    delete[] temp;
}

/**
 * 自底向上的归并排序（迭代版本）
 */
void bottomUpMergeSort(int arr[], int n) {
    int* temp = new int[n];
    
    for (int currSize = 1; currSize < n; currSize *= 2) {
        for (int leftStart = 0; leftStart < n - 1; leftStart += 2 * currSize) {
            int mid = min(leftStart + currSize - 1, n - 1);
            int rightEnd = min(leftStart + 2 * currSize - 1, n - 1);
            
            if (mid < rightEnd) {
                optimizedMerge(arr, leftStart, mid, rightEnd, temp);
            }
        }
    }
    
    delete[] temp;
}

/**
 * 原地归并排序（空间复杂度O(1)，但时间复杂度退化）
 */
void inPlaceMerge(int arr[], int left, int mid, int right) {
    int start2 = mid + 1;
    
    // 如果直接合并已经有序
    if (arr[mid] <= arr[start2]) {
        return;
    }
    
    while (left <= mid && start2 <= right) {
        if (arr[left] <= arr[start2]) {
            left++;
        } else {
            int value = arr[start2];
            int index = start2;
            
            // 移动元素
            while (index != left) {
                arr[index] = arr[index - 1];
                index--;
            }
            arr[left] = value;
            
            left++;
            mid++;
            start2++;
        }
    }
}

void inPlaceMergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        inPlaceMergeSort(arr, left, mid);
        inPlaceMergeSort(arr, mid + 1, right);
        inPlaceMerge(arr, left, mid, right);
    }
}

/**
 * 混合排序：小数组使用插入排序
 */
const int MERGE_INSERTION_THRESHOLD = 10;

void hybridMergeSort(int arr[], int left, int right, int temp[]) {
    if (right - left <= MERGE_INSERTION_THRESHOLD) {
        // 对小数组使用插入排序
        for (int i = left + 1; i <= right; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= left && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    } else {
        int mid = left + (right - left) / 2;
        hybridMergeSort(arr, left, mid, temp);
        hybridMergeSort(arr, mid + 1, right, temp);
        optimizedMerge(arr, left, mid, right, temp);
    }
}

// 测试函数
void testMergeSort() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90, 5, 77, 30};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "原数组: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    mergeSort(arr, 0, n - 1);
    
    cout << "排序后: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

### 复杂度分析

| 情况     | 时间复杂度 | 说明                             |
| -------- | ---------- | -------------------------------- |
| 最好情况 | O(n log n) | 即使数组已有序，仍需要分治和合并 |
| 最坏情况 | O(n log n) | 时间复杂度稳定                   |
| 平均情况 | O(n log n) | 与最好、最坏情况相同             |

**空间复杂度**：O(n) - 需要额外的临时数组存储

### 嵌入式应用注意点

#### 优点

1. **稳定排序**：相等元素的相对位置不变
2. **时间复杂度稳定**：始终保持O(n log n)
3. **适合链表**：特别适合链表结构的排序
4. **可并行化**：分治特性使其易于并行实现

#### 缺点

1. **空间复杂度高**：需要O(n)的额外空间
2. **不是原地排序**：需要额外内存

#### 嵌入式优化技巧

```cpp
// 针对嵌入式的优化版本
template<int MAX_SIZE>
class EmbeddedMergeSort {
private:
    int temp[MAX_SIZE];  // 预分配的临时数组
    
    void merge(int arr[], int left, int mid, int right) {
        int i = left, j = mid + 1, k = left;
        
        // 使用预分配的临时数组
        while (i <= mid && j <= right) {
            temp[k++] = (arr[i] <= arr[j]) ? arr[i++] : arr[j++];
        }
        
        while (i <= mid) temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];
        
        // 复制回原数组
        for (int idx = left; idx <= right; idx++) {
            arr[idx] = temp[idx];
        }
    }
    
public:
    void sort(int arr[], int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            sort(arr, left, mid);
            sort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
};

// 使用示例
void embeddedMergeSortExample() {
    const int SIZE = 100;
    EmbeddedMergeSort<SIZE> sorter;
    int arr[SIZE];
    // ... 初始化数组
    sorter.sort(arr, 0, SIZE - 1);
}
```

------

## 堆排序 (Heap Sort)

### 算法思想

堆排序利用堆这种数据结构来实现排序。堆是一个完全二叉树，分为最大堆和最小堆。堆排序首先构建最大堆，然后重复提取最大元素并重新调整堆结构。

### 算法步骤

1. **构建最大堆**：将无序数组构建成最大堆
2. **交换根节点与最后一个节点**：将最大元素移到数组末尾
3. **重新调整堆**：对剩余元素重新构建最大堆
4. **重复步骤2-3**：直到堆中只有一个元素

### C++实现

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

/**
 * 调整堆（向下调整）
 * @param arr 数组
 * @param n 堆大小
 * @param i 需要调整的节点索引
 */
void heapify(int arr[], int n, int i) {
    int largest = i;       // 初始化最大值为根节点
    int left = 2 * i + 1;  // 左孩子索引
    int right = 2 * i + 2; // 右孩子索引
    
    // 如果左孩子存在且大于根节点
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    // 如果右孩子存在且大于当前最大值
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // 如果最大值不是根节点
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);  // 递归调整受影响的子树
    }
}

/**
 * 堆排序主函数
 */
void heapSort(int arr[], int n) {
    // 构建最大堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 逐个提取元素
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);  // 将根（最大值）移到末尾
        heapify(arr, i, 0);    // 重新调整剩余元素为堆
    }
}

/**
 * 迭代版本的堆调整（避免递归）
 */
void iterativeHeapify(int arr[], int n, int i) {
    while (true) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest == i) {
            break;  // 堆性质已满足
        }
        
        swap(arr[i], arr[largest]);
        i = largest;
    }
}

void iterativeHeapSort(int arr[], int n) {
    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        iterativeHeapify(arr, n, i);
    }
    
    // 排序
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        iterativeHeapify(arr, i, 0);
    }
}

/**
 * 堆的基本操作类（用于理解堆的工作原理）
 */
class MaxHeap {
private:
    int* heap;
    int capacity;
    int size;
    
    void heapifyUp(int index) {
        if (index == 0) return;
        
        int parent = (index - 1) / 2;
        if (heap[parent] < heap[index]) {
            swap(heap[parent], heap[index]);
            heapifyUp(parent);
        }
    }
    
    void heapifyDown(int index) {
        int largest = index;
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        
        if (left < size && heap[left] > heap[largest]) {
            largest = left;
        }
        
        if (right < size && heap[right] > heap[largest]) {
            largest = right;
        }
        
        if (largest != index) {
            swap(heap[index], heap[largest]);
            heapifyDown(largest);
        }
    }
    
public:
    MaxHeap(int cap) : capacity(cap), size(0) {
        heap = new int[capacity];
    }
    
    ~MaxHeap() {
        delete[] heap;
    }
    
    void insert(int value) {
        if (size >= capacity) return;
        
        heap[size] = value;
        heapifyUp(size);
        size++;
    }
    
    int extractMax() {
        if (size <= 0) return -1;
        if (size == 1) {
            size--;
            return heap[0];
        }
        
        int root = heap[0];
        heap[0] = heap[size - 1];
        size--;
        heapifyDown(0);
        
        return root;
    }
    
    void printHeap() {
        for (int i = 0; i < size; i++) {
            cout << heap[i] << " ";
        }
        cout << endl;
    }
};

/**
 * 优先队列实现（基于堆）
 */
template<typename T>
class PriorityQueue {
private:
    vector<T> heap;
    
    void heapifyUp(int index) {
        if (index == 0) return;
        
        int parent = (index - 1) / 2;
        if (heap[parent] < heap[index]) {
            swap(heap[parent], heap[index]);
            heapifyUp(parent);
        }
    }
    
    void heapifyDown(int index) {
        int largest = index;
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        
        if (left < heap.size() && heap[left] > heap[largest]) {
            largest = left;
        }
        
        if (right < heap.size() && heap[right] > heap[largest]) {
            largest = right;
        }
        
        if (largest != index) {
            swap(heap[index], heap[largest]);
            heapifyDown(largest);
        }
    }
    
public:
    void push(const T& value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }
    
    T pop() {
        if (heap.empty()) throw runtime_error("Priority queue is empty");
        
        T result = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        
        if (!heap.empty()) {
            heapifyDown(0);
        }
        
        return result;
    }
    
    bool empty() const {
        return heap.empty();
    }
    
    size_t size() const {
        return heap.size();
    }
};

// 测试函数
void testHeapSort() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90, 5, 77, 30};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "原数组: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    heapSort(arr, n);
    
    cout << "排序后: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

### 复杂度分析

| 情况     | 时间复杂度 | 说明                         |
| -------- | ---------- | ---------------------------- |
| 最好情况 | O(n log n) | 构建堆O(n) + n次调整O(log n) |
| 最坏情况 | O(n log n) | 与最好情况相同               |
| 平均情况 | O(n log n) | 时间复杂度稳定               |

**空间复杂度**：O(1) - 原地排序（不考虑递归栈）

### 嵌入式应用注意点

#### 优点

1. **时间复杂度稳定**：始终保持O(n log n)
2. **原地排序**：只需要O(1)的额外空间
3. **不依赖数据分布**：性能不受输入数据影响
4. **适合选择问题**：快速找到最大/最小的k个元素

#### 缺点

1. **不稳定排序**：相等元素的相对位置可能改变
2. **缓存性能差**：堆操作的内存访问模式不连续
3. **常数因子大**：实际运行时间可能比快速排序慢

#### 嵌入式优化技巧

```cpp
// 针对嵌入式的优化版本
void embeddedHeapSort(int* arr, int n) {
    // 使用位运算优化索引计算
    auto parent = [](int i) { return (i - 1) >> 1; };
    auto leftChild = [](int i) { return (i << 1) + 1; };
    auto rightChild = [](int i) { return (i + 1) << 1; };
    
    // 构建最大堆
    for (int i = (n >> 1) - 1; i >= 0; i--) {
        int current = i;
        
        while (true) {
            int largest = current;
            int left = leftChild(current);
            int right = rightChild(current);
            
            if (left < n && arr[left] > arr[largest]) {
                largest = left;
            }
            
            if (right < n && arr[right] > arr[largest]) {
                largest = right;
            }
            
            if (largest == current) break;
            
            // 手动交换避免函数调用
            int temp = arr[current];
            arr[current] = arr[largest];
            arr[largest] = temp;
            
            current = largest;
        }
    }
    
    // 排序阶段
    for (int i = n - 1; i > 0; i--) {
        // 交换
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        
        // 调整堆
        int current = 0;
        while (true) {
            int largest = current;
            int left = leftChild(current);
            int right = rightChild(current);
            
            if (left < i && arr[left] > arr[largest]) {
                largest = left;
            }
            
            if (right < i && arr[right] > arr[largest]) {
                largest = right;
            }
            
            if (largest == current) break;
            
            temp = arr[current];
            arr[current] = arr[largest];
            arr[largest] = temp;
            
            current = largest;
        }
    }
}
```

------

## 嵌入式环境下的排序算法选择

### 选择标准

#### 1. 内存限制

- **RAM极少（< 1KB）**：插入排序、选择排序
- **RAM适中（1KB-10KB）**：快速排序、堆排序
- **RAM充足（> 10KB）**：归并排序

#### 2. 数据规模

- **小数据集（n < 50）**：插入排序
- **中等数据集（50 ≤ n ≤ 1000）**：快速排序
- **大数据集（n > 1000）**：归并排序、堆排序

#### 3. 实时性要求

- **硬实时**：堆排序（时间复杂度稳定）
- **软实时**：快速排序（平均性能好）
- **非实时**：根据其他因素选择

#### 4. 稳定性要求

- **需要稳定**：插入排序、归并排序、冒泡排序
- **不需要稳定**：选择排序、快速排序、堆排序

### 推荐方案

```cpp
/**
 * 自适应排序算法 - 根据数据特征选择最优算法
 */
void adaptiveSort(int arr[], int n) {
    if (n <= 1) return;
    
    // 小数组使用插入排序
    if (n <= 10) {
        insertionSort(arr, n);
        return;
    }
    
    // 检查数组是否已经基本有序
    int inversions = 0;
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            inversions++;
        }
    }
    
    // 如果逆序对很少，使用插入排序
    if (inversions < n / 4) {
        insertionSort(arr, n);
        return;
    }
    
    // 检查是否有很多重复元素
    int uniqueCount = 1;
    for (int i = 1; i < n; i++) {
        bool found = false;
        for (int j = 0; j < i; j++) {
            if (arr[i] == arr[j]) {
                found = true;
                break;
            }
        }
        if (!found) uniqueCount++;
        if (uniqueCount > n / 2) break;
    }
    
    // 重复元素多，使用三路快排
    if (uniqueCount < n / 2) {
        threeWayQuickSort(arr, 0, n - 1);
        return;
    }
    
    // 默认使用混合快排
    hybridQuickSort(arr, 0, n - 1);
}

/**
 * 嵌入式专用排序库
 */
template<int MAX_SIZE>
class EmbeddedSorter {
private:
    int temp[MAX_SIZE];  // 预分配辅助空间
    
public:
    void sort(int arr[], int n, const char* algorithm = "auto") {
        if (strcmp(algorithm, "insertion") == 0) {
            insertionSort(arr, n);
        } else if (strcmp(algorithm, "selection") == 0) {
            selectionSort(arr, n);
        } else if (strcmp(algorithm, "heap") == 0) {
            heapSort(arr, n);
        } else if (strcmp(algorithm, "merge") == 0) {
            optimizedMergeSort(arr, 0, n - 1, temp);
        } else {
            adaptiveSort(arr, n);  // 自动选择
        }
    }
};
```

------

## 面试常见问题

### 1. 基础概念题

**Q: 什么是稳定排序？为什么需要稳定排序？**

A: 稳定排序是指相等元素在排序后保持原有的相对顺序。需要稳定排序的场景包括：

- 多关键字排序（如先按年龄排序，再按姓名排序）
- 保持原有数据的相对位置信息
- 在已排序数据上进行二次排序

```cpp
// 稳定排序示例
struct Person {
    string name;
    int age;
};

// 稳定排序可以保证同年龄的人按原来的顺序排列
```

**Q: 原地排序和非原地排序的区别？**

A:

- **原地排序**：只使用O(1)的额外空间，如插入排序、选择排序、堆排序
- **非原地排序**：需要O(n)或更多额外空间，如归并排序

### 2. 算法选择题

**Q: 在什么情况下选择插入排序？**

A:

- 数据规模小（n < 50）
- 数组已经基本有序
- 需要稳定排序
- 内存极其有限的嵌入式系统
- 在线算法（边接收数据边排序）

**Q: 快速排序的最坏情况是什么？如何避免？**

A:

- **最坏情况**：每次划分都极其不均匀，时间复杂度退化为O(n²)
- **避免方法**：
  1. 随机选择基准元素
  2. 三数取中法选择基准
  3. 使用三路快排处理重复元素
  4. 当数组较小时改用插入排序

### 3. 优化问题

**Q: 如何优化归并排序在嵌入式系统中的内存使用？**

A:

1. **预分配辅助数组**：避免频繁的内存分配和释放
2. **混合排序**：小数组使用插入排序减少递归开销
3. **自底向上归并**：避免递归栈的开销
4. **原地归并**：虽然时间复杂度会退化，但空间复杂度为O(1)

```cpp
// 优化示例：预分配辅助数组
template<int MAX_SIZE>
class OptimizedMergeSort {
    int aux[MAX_SIZE];
    
public:
    void sort(int arr[], int n) {
        if (n <= MAX_SIZE) {
            mergeSortWithAux(arr, 0, n-1, aux);
        }
    }
};
```

### 4. 复杂度分析题

**Q: 为什么快速排序的平均时间复杂度是O(n log n)？**

A:

- 每次划分将数组分为两部分，理想情况下大小相等
- 递归深度为log n层
- 每层的划分操作需要O(n)时间
- 总时间复杂度：O(n) × O(log n) = O(n log n)

**Q: 堆排序为什么不如快速排序常用？**

A:

- **缓存性能差**：堆操作的内存访问模式不连续
- **常数因子大**：虽然都是O(n log n)，但堆排序的常数更大
- **不稳定**：破坏了相等元素的相对顺序

### 5. 实现细节题

**Q: 实现一个查找第k小元素的算法**

```cpp
/**
 * 快速选择算法 - 查找第k小的元素
 * 平均时间复杂度：O(n)
 */
int quickSelect(int arr[], int left, int right, int k) {
    if (left == right) return arr[left];
    
    int pivotIndex = partition(arr, left, right);
    
    if (k == pivotIndex) {
        return arr[k];
    } else if (k < pivotIndex) {
        return quickSelect(arr, left, pivotIndex - 1, k);
    } else {
        return quickSelect(arr, pivotIndex + 1, right, k);
    }
}

// 查找第k小元素（k从0开始）
int findKthSmallest(int arr[], int n, int k) {
    return quickSelect(arr, 0, n - 1, k);
}
```

**Q: 如何检测数组是否已经排序？**

```cpp
bool isSorted(int arr[], int n, bool ascending = true) {
    for (int i = 1; i < n; i++) {
        if (ascending ? arr[i] < arr[i-1] : arr[i] > arr[i-1]) {
            return false;
        }
    }
    return true;
}
```

### 6. 特殊排序问题

**Q: 如何排序包含0、1、2的数组（荷兰国旗问题）？**

```cpp
/**
 * 荷兰国旗问题 - 三色排序
 * 时间复杂度：O(n)，空间复杂度：O(1)
 */
void dutchFlagSort(int arr[], int n) {
    int low = 0, mid = 0, high = n - 1;
    
    while (mid <= high) {
        switch (arr[mid]) {
            case 0:
                swap(arr[low++], arr[mid++]);
                break;
            case 1:
                mid++;
                break;
            case 2:
                swap(arr[mid], arr[high--]);
                break;
        }
    }
}
```

**Q: 如何合并两个已排序数组？**

```cpp
void mergeTwoSortedArrays(int arr1[], int n1, int arr2[], int n2, int result[]) {
    int i = 0, j = 0, k = 0;
    
    while (i < n1 && j < n2) {
        if (arr1[i] <= arr2[j]) {
            result[k++] = arr1[i++];
        } else {
            result[k++] = arr2[j++];
        }
    }
    
    while (i < n1) result[k++] = arr1[i++];
    while (j < n2) result[k++] = arr2[j++];
}
```

------

## 性能测试和基准测试

### 测试框架

```cpp
#include <chrono>
#include <random>
#include <iomanip>

class SortTester {
private:
    mt19937 rng;
    
public:
    SortTester() : rng(random_device{}()) {}
    
    // 生成测试数据
    void generateRandomArray(int arr[], int n, int minVal = 0, int maxVal = 1000) {
        uniform_int_distribution<int> dis(minVal, maxVal);
        for (int i = 0; i < n; i++) {
            arr[i] = dis(rng);
        }
    }
    
    void generateSortedArray(int arr[], int n) {
        for (int i = 0; i < n; i++) {
            arr[i] = i;
        }
    }
    
    void generateReverseSortedArray(int arr[], int n) {
        for (int i = 0; i < n; i++) {
            arr[i] = n - i - 1;
        }
    }
    
    // 性能测试
    template<typename SortFunc>
    double measureTime(SortFunc sortFunc, int arr[], int n) {
        auto start = chrono::high_resolution_clock::now();
        sortFunc(arr, n);
        auto end = chrono::high_resolution_clock::now();
        
        auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
        return duration.count() / 1000.0;  // 返回毫秒
    }
    
    // 验证排序正确性
    bool verifySorted(int arr[], int n) {
        for (int i = 1; i < n; i++) {
            if (arr[i] < arr[i-1]) {
                return false;
            }
        }
        return true;
    }
    
    // 综合测试
    void comprehensiveTest() {
        const int sizes[] = {10, 100, 1000, 10000};
        const int numSizes = sizeof(sizes) / sizeof(sizes[0]);
        
        cout << setw(12) << "Algorithm" << setw(8) << "Size" 
             << setw(12) << "Random(ms)" << setw(12) << "Sorted(ms)" 
             << setw(12) << "Reverse(ms)" << endl;
        cout << string(56, '-') << endl;
        
        for (int i = 0; i < numSizes; i++) {
            int n = sizes[i];
            int* arr1 = new int[n];
            int* arr2 = new int[n];
            int* arr3 = new int[n];
            
            // 测试插入排序
            generateRandomArray(arr1, n);
            generateSortedArray(arr2, n);
            generateReverseSortedArray(arr3, n);
            
            double time1 = measureTime([](int arr[], int n) { insertionSort(arr, n); }, arr1, n);
            double time2 = measureTime([](int arr[], int n) { insertionSort(arr, n); }, arr2, n);
            double time3 = measureTime([](int arr[], int n) { insertionSort(arr, n); }, arr3, n);
            
            cout << setw(12) << "Insertion" << setw(8) << n 
                 << setw(12) << time1 << setw(12) << time2 << setw(12) << time3 << endl;
            
            // 测试快速排序
            generateRandomArray(arr1, n);
            generateSortedArray(arr2, n);
            generateReverseSortedArray(arr3, n);
            
            time1 = measureTime([](int arr[], int n) { quickSort(arr, 0, n-1); }, arr1, n);
            time2 = measureTime([](int arr[], int n) { quickSort(arr, 0, n-1); }, arr2, n);
            time3 = measureTime([](int arr[], int n) { quickSort(arr, 0, n-1); }, arr3, n);
            
            cout << setw(12) << "QuickSort" << setw(8) << n 
                 << setw(12) << time1 << setw(12) << time2 << setw(12) << time3 << endl;
            
            delete[] arr1;
            delete[] arr2;
            delete[] arr3;
        }
    }
};
```

------

## 高级主题

### 1. 外部排序

当数据量超过内存容量时，需要使用外部排序：

```cpp
/**
 * 外部归并排序 - 适用于大数据量
 */
class ExternalSort {
private:
    int bufferSize;
    string tempDir;
    
    void createSortedChunks(const string& inputFile, vector<string>& chunkFiles) {
        ifstream input(inputFile);
        vector<int> buffer(bufferSize);
        int chunkNum = 0;
        
        while (!input.eof()) {
            int count = 0;
            while (count < bufferSize && input >> buffer[count]) {
                count++;
            }
            
            if (count > 0) {
                // 排序当前块
                sort(buffer.begin(), buffer.begin() + count);
                
                // 写入临时文件
                string chunkFile = tempDir + "/chunk_" + to_string(chunkNum++) + ".tmp";
                ofstream chunk(chunkFile);
                for (int i = 0; i < count; i++) {
                    chunk << buffer[i] << "\n";
                }
                chunk.close();
                chunkFiles.push_back(chunkFile);
            }
        }
        input.close();
    }
    
    void mergeChunks(const vector<string>& chunkFiles, const string& outputFile) {
        vector<ifstream> inputs(chunkFiles.size());
        vector<int> currentValues(chunkFiles.size());
        vector<bool> hasValue(chunkFiles.size());
        
        // 打开所有块文件
        for (size_t i = 0; i < chunkFiles.size(); i++) {
            inputs[i].open(chunkFiles[i]);
            hasValue[i] = static_cast<bool>(inputs[i] >> currentValues[i]);
        }
        
        ofstream output(outputFile);
        
        while (true) {
            int minIndex = -1;
            int minValue = INT_MAX;
            
            // 找到最小值
            for (size_t i = 0; i < chunkFiles.size(); i++) {
                if (hasValue[i] && currentValues[i] < minValue) {
                    minValue = currentValues[i];
                    minIndex = i;
                }
            }
            
            if (minIndex == -1) break;  // 所有文件都已处理完
            
            output << minValue << "\n";
            hasValue[minIndex] = static_cast<bool>(inputs[minIndex] >> currentValues[minIndex]);
        }
        
        // 关闭文件
        for (auto& input : inputs) {
            input.close();
        }
        output.close();
        
        // 删除临时文件
        for (const auto& file : chunkFiles) {
            remove(file.c_str());
        }
    }
    
public:
    ExternalSort(int bufSize = 1000, const string& tmpDir = "./temp") 
        : bufferSize(bufSize), tempDir(tmpDir) {}
    
    void sort(const string& inputFile, const string& outputFile) {
        vector<string> chunkFiles;
        createSortedChunks(inputFile, chunkFiles);
        mergeChunks(chunkFiles, outputFile);
    }
};
```

### 2. 并行排序

利用多核处理器加速排序：

```cpp
#include <thread>
#include <future>

/**
 * 并行归并排序
 */
class ParallelMergeSort {
private:
    int threshold;  // 切换到串行排序的阈值
    
    void parallelMergeSort(int arr[], int left, int right, int temp[], int depth) {
        if (right - left <= threshold || depth <= 0) {
            // 串行排序
            mergeSort(arr, left, right);
            return;
        }
        
        int mid = left + (right - left) / 2;
        
        // 并行处理两半
        auto leftTask = async(launch::async, [&]() {
            parallelMergeSort(arr, left, mid, temp, depth - 1);
        });
        
        parallelMergeSort(arr, mid + 1, right, temp, depth - 1);
        
        leftTask.wait();
        
        // 合并结果
        merge(arr, left, mid, right, temp);
    }
    
public:
    ParallelMergeSort(int t = 1000) : threshold(t) {}
    
    void sort(int arr[], int n) {
        int* temp = new int[n];
        int maxDepth = log2(thread::hardware_concurrency());
        parallelMergeSort(arr, 0, n - 1, temp, maxDepth);
        delete[] temp;
    }
};
```

------

## 总结与建议

### 算法选择总结表

| 算法     | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 最佳使用场景           |
| -------- | ---------------- | ---------- | ------ | ---------------------- |
| 插入排序 | O(n²)            | O(1)       | 稳定   | 小数组，基本有序数据   |
| 选择排序 | O(n²)            | O(1)       | 不稳定 | 交换代价高的场景       |
| 冒泡排序 | O(n²)            | O(1)       | 稳定   | 教学演示，简单实现     |
| 快速排序 | O(n log n)       | O(log n)   | 不稳定 | 一般场景，平均性能好   |
| 归并排序 | O(n log n)       | O(n)       | 稳定   | 需要稳定排序，外部排序 |
| 堆排序   | O(n log n)       | O(1)       | 不稳定 | 实时系统，选择问题     |

### 嵌入式开发建议

1. **内存优先**：优先选择原地排序算法
2. **性能稳定**：实时系统选择堆排序
3. **混合策略**：根据数据规模动态选择算法
4. **预分配内存**：避免动态内存分配
5. **循环展开**：对关键路径进行优化
6. **位运算优化**：使用位运算替代除法和乘法

### 面试准备重点

1. **熟练手写**：插入排序、快速排序、归并排序、堆排序
2. **复杂度分析**：能够准确分析时间和空间复杂度
3. **优化技巧**：了解各种优化方法和适用场景
4. **实际应用**：能够根据具体需求选择合适算法
5. **边界处理**：注意空数组、单元素数组等边界情况

### 进阶学习方向

1. **非比较排序**：计数排序、基数排序、桶排序
2. **字符串排序**：后缀数组、基数排序变种
3. **并行排序**：多线程、SIMD优化
4. **外部排序**：大数据处理
5. **近似排序**：在精度和性能间权衡

希望这份笔记能够帮助你在嵌入式软件开发的道路上更进一步！记住，理论学习很重要，但更重要的是多动手实践，在实际项目中应用这些算法，积累经验。