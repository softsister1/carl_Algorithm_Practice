//========== BFS的两种形式对比 ==========

// 🔥 形式1: 不需要levelSize - 逐个处理节点
// 适用：只关心访问每个节点，不关心层级关系

void bfs_simple(TreeNode* root) {
    if (!root) return;
    

    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        // 处理当前节点（不关心它在第几层）
        cout << node->val << " ";
        
        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
}

// 🔥 形式2: 需要levelSize - 按层处理
// 适用：需要区分层级，或者对每层进行特殊处理


    

```c++
void bfs_bylevel(TreeNode* root) {
    if (!root) return;
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();  // 🎯 关键：记录当前层节点数

        cout << "第" << level << "层: ";

        // 只处理当前层的节点
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();

            cout << node->val << " ";

            // 下一层节点会在这里加入，但不会在本轮循环中处理
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }

        cout << endl;  // 换行，表示这一层结束
}
}
```

//========== 具体题目对比 ==========

// ❌ 不需要levelSize的题目类型：

// 1. 简单遍历所有节点
vector<int> getAllNodes(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        result.push_back(node->val);  // 只要访问每个节点
        
        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
    
    return result;
}

// 2. 查找特定值（找到就退出）
bool findValue(TreeNode* root, int target) {
    if (!root) return false;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node->val == target) return true;  // 找到就返回
        
        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
    
    return false;
}

// ✅ 需要levelSize的题目类型：

// 1. 层序遍历 - 需要分层输出
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();  // 🎯 必须要！
        vector<int> currentLevel;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            currentLevel.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(currentLevel);  // 保存这一层
    }
    
    return result;
}

// 2. 右视图 - 需要每层最后一个节点
vector<int> rightSideView(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();  // 🎯 必须要！
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            // 只有最后一个节点才加入结果
            if (i == levelSize - 1) {
                result.push_back(node->val);
            }
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    
    return result;
}

// 3. 层平均值 - 需要计算每层平均
vector<double> averageOfLevels(TreeNode* root) {
    vector<double> result;
    if (!root) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();  // 🎯 必须要！
        long sum = 0;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            sum += node->val;  // 累加当前层所有值
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back((double)sum / levelSize);  // 计算平均值
    }
    
    return result;
}

// 4. 最小深度 - 遇到叶子节点就是最短路径
int minDepth(TreeNode* root) {
    if (!root) return 0;
    
    queue<TreeNode*> q;
    q.push(root);
    int depth = 0;
    
    while (!q.empty()) {
        int levelSize = q.size();  // 🎯 必须要！
        depth++;  // 进入新的一层
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            // 如果是叶子节点，立即返回深度
            if (!node->left && !node->right) {
                return depth;
            }
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    
    return depth;
}





/*
=========== 什么时候需要levelSize？ ===========

🔥 核心判断标准：
- 需要levelSize：题目要求按层处理，或需要知道层级信息
- 不需要levelSize：只是简单遍历，不关心层级关系

=========== 需要levelSize的场景 ===========

✅ 1. 题目明确提到"层"
   - 层序遍历
   - 自底向上层序遍历  
   - 每层节点个数
   - 每层最大值/最小值

✅ 2. 题目要求每层的特定位置
   - 右视图（每层最右）
   - 左视图（每层最左）
   - 每层第一个/最后一个

✅ 3. 题目需要层级计算
   - 层平均值
   - 每层和
   - 最小深度（按层计算深度）

✅ 4. 题目要求按层的特殊操作
   - 锯齿形遍历（奇偶层方向不同）
   - 填充next指针（连接同层节点）
   - 按层反转

=========== 不需要levelSize的场景 ===========

❌ 1. 简单的全部节点遍历
   - 访问所有节点
   - 查找特定值
   - 统计节点总数

❌ 2. 不关心层级的操作
   - 节点值求和
   - 打印所有节点
   - 收集所有叶子节点

❌ 3. 找到即停止的搜索
   - 查找目标值
   - 验证完全二叉树

=========== 代码模式识别 ===========

// 🔥 需要levelSize的典型模式：
while (!q.empty()) {
    int levelSize = q.size();        // 固定当前层大小
    
    // 对当前层进行某种操作（收集、计算、判断）
    for (int i = 0; i < levelSize; i++) {
        TreeNode* node = q.front();
        q.pop();
        
        // 在这里可能需要判断位置：
        // if (i == 0)              // 每层第一个
        // if (i == levelSize - 1)  // 每层最后一个
        
        // 添加子节点到下一层
        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
    
    // 这里通常有层级相关的操作
    // 比如：层数++, 保存当前层结果等
}

// 🔥 不需要levelSize的典型模式：
while (!q.empty()) {
    TreeNode* node = q.front();
    q.pop();
    
    // 处理当前节点（不关心层级）
    process(node);
    
    if (node->left) q.push(node->left);
    if (node->right) q.push(node->right);
}

=========== 具体题目分类 ===========

📌 需要levelSize的题目：
- 102. 二叉树的层序遍历 ⭐⭐⭐⭐⭐
- 107. 二叉树的层序遍历 II ⭐⭐⭐⭐
- 199. 二叉树的右视图 ⭐⭐⭐⭐⭐
- 637. 二叉树的层平均值 ⭐⭐⭐
- 111. 二叉树的最小深度 ⭐⭐⭐⭐
- 116. 填充每个节点的下一个右侧节点指针 ⭐⭐⭐
- 429. N叉树的层序遍历 ⭐⭐⭐
- 515. 在每个树行中找最大值 ⭐⭐⭐
- 103. 二叉树的锯齿形层序遍历 ⭐⭐⭐

📌 不需要levelSize的题目：
- 遍历所有节点并处理
- 查找特定值
- 计算节点总数
- 判断是否存在某个值

=========== 记忆技巧 ===========

🧠 快速判断法：
1. 看题目关键词：
   - 有"层"字 → 需要levelSize
   - 有"每层" → 需要levelSize  
   - 有"视图" → 需要levelSize
   - 有"深度"但要最短路径 → 需要levelSize

2. 看返回类型：
   - vector<vector<int>> → 需要levelSize（二维数组，按层分组）
   - vector<int> → 可能需要levelSize（如果是每层取一个）
   - int/bool → 通常不需要levelSize

3. 看处理逻辑：
   - 需要知道"这是第几个节点" → 需要levelSize
   - 需要知道"这是第几层" → 需要levelSize
   - 只是简单访问 → 不需要levelSize

=========== 常见错误 ===========

❌ 错误1：该用levelSize时没用
// 想要按层输出，但没有levelSize
while (!q.empty()) {
    TreeNode* node = q.front();
    q.pop();
    cout << node->val << " ";  // 这样输出不是按层的！
    // ...
}

✅ 正确：
while (!q.empty()) {
    int levelSize = q.size();
    for (int i = 0; i < levelSize; i++) {
        TreeNode* node = q.front();
        q.pop();
        cout << node->val << " ";
        // ...
    }
    cout << endl;  // 层结束换行
}

❌ 错误2：不该用levelSize时用了
// 简单遍历，不需要levelSize
while (!q.empty()) {
    int levelSize = q.size();  // 多余的！
    for (int i = 0; i < levelSize; i++) {  // 多余的循环！
        TreeNode* node = q.front();
        q.pop();
        sum += node->val;  // 简单累加，不需要按层
        // ...
    }
}

✅ 正确：
while (!q.empty()) {
    TreeNode* node = q.front();
    q.pop();
    sum += node->val;  // 直接处理
    // ...
}
*/