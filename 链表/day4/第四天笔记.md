# 代码随想录算法训练营第四天 | 链表part02

## 今日任务
- 24. 两两交换链表中的节点
- 19. 删除链表的倒数第N个节点
- 160. 相交链表
- 142. 环形链表 II

## 学习资源
- 文章链接：[链表相交](https://programmercarl.com/面试题02.07.链表相交.html)
- 视频讲解：[环形链表](https://www.bilibili.com/video/BV1if4y1d7ob)

---

## 24. 两两交换链表中的节点

### 题目描述
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

###  核心思路：虚拟头节点 + 三指针交换

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* prev = dummy;
        
        // 确保有两个节点可以交换
        while (prev->next != nullptr && prev->next->next != nullptr) {
            // 定义要交换的两个节点
            ListNode* first = prev->next;
            ListNode* second = prev->next->next;
            
            // 执行交换：prev → second → first → next
            prev->next = second;
            first->next = second->next;
            second->next = first;
            
            // 移动prev指针，准备下一轮交换
            prev = first;
        }
        
        ListNode* newHead = dummy->next;
        delete dummy;
        return newHead;
    }
};
```

### 交换过程图解
```
原状态：prev → first → second → next
目标：   prev → second → first → next

三步操作：
1. prev->next = second     (prev指向second)
2. first->next = second->next  (first指向next)
3. second->next = first    (second指向first)
```

### 我犯过的错误
```cpp
// ❌ 循环条件错误
while (pre != nullptr) {  // 会导致无限循环

// ❌ 指针操作顺序错误
second->next = first;       // 先这样会断开链表
first->next = second->next; // 再这样就找不到原来的next了

// ✅ 正确的顺序和条件
while (prev->next != nullptr && prev->next->next != nullptr) {
    // 先保存连接，再交换
    first->next = second->next;
    second->next = first;
}
```

---

## 19. 删除链表的倒数第N个节点

### 题目描述
给你一个链表，删除链表的倒数第n个结点，并且返回链表的头结点。

### 核心思路：快慢双指针

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* fast = dummy;
        ListNode* slow = dummy;
        
        // 快指针先走n+1步
        for (int i = 0; i <= n; i++) {
            fast = fast->next;
        }
        
        // 快慢指针同时移动
        while (fast != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }
        
        // 删除slow的下一个节点
        ListNode* nodeToDelete = slow->next;
        slow->next = slow->next->next;
        delete nodeToDelete;
        
        ListNode* result = dummy->next;
        delete dummy;
        return result;
    }
};
```

### 算法关键点
1. **为什么快指针走n+1步？**
   - 确保慢指针最终停在要删除节点的前一个位置
   
2. **双指针的距离保持不变**
   ```
   初始：dummy→1→2→3→4→5，n=2
   快指针走3步：
   slow      fast
    ↓         ↓  
   dummy→1→2→3→4→5→null
   
   同时移动到fast=null：
         slow    fast
          ↓       ↓
   dummy→1→2→3→4→5→null
   
   slow正好在要删除节点4的前一个！
   ```

### 时间复杂度：O(n)，一次遍历

---

## 160. 相交链表

### 题目描述
给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。

### 核心思路：双指针走相同距离

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == nullptr || headB == nullptr) {
            return nullptr;
        }
        
        ListNode* pA = headA;
        ListNode* pB = headB;
        
        while (pA != pB) {
            // pA走完链表A后跳转到链表B
            pA = (pA == nullptr) ? headB : pA->next;
            // pB走完链表B后跳转到链表A  
            pB = (pB == nullptr) ? headA : pB->next;
        }
        
        return pA;  // 相交点或nullptr
    }
};
```

### 数学原理
设链表A长度为a+c，链表B长度为b+c（c为公共部分）

**关键洞察**：`a + c + b = b + c + a`

```
pA路径：链表A(a+c) + 链表B独有部分(b) = a + b + c
pB路径：链表B(b+c) + 链表A独有部分(a) = a + b + c

两个指针走相同距离后：
- 有相交：同时到达公共部分第一个节点
- 无相交：同时到达nullptr
```

### 执行过程示例
```
链表A: 4→1→8→4→5  (a=2, c=3)
链表B: 5→6→1→8→4→5  (b=3, c=3)

pA路径: 4→1→8→4→5→5→6→1→8  (第9步相遇)
pB路径: 5→6→1→8→4→5→4→1→8  (第9步相遇)
```

### 理解要点
- **比较的是节点地址**，不是节点值
- **相交的定义**：物理内存地址相同，不是值相同

---

## 142. 环形链表 II

### 题目描述
给定一个链表的头节点head，返回链表开始入环的第一个节点。如果链表无环，则返回null。

### 核心思路：Floyd判圈算法（两阶段）

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (head == nullptr) return nullptr;
        
        ListNode* fast = head;
        ListNode* slow = head;
        
        // 第一阶段：快慢指针检测环
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            
            if (slow == fast) {
                break;  // 找到相遇点
            }
        }
        
        // 无环的情况
        if (fast == nullptr || fast->next == nullptr) {
            return nullptr;
        }
        
        // 第二阶段：寻找环入口
        slow = head;
        while (slow != fast) {
            slow = slow->next;
            fast = fast->next;  // 注意：这里fast每次也走1步
        }
        
        return slow;  // 环入口
    }
};
```

### 数学原理推导
```
链表结构：起点 → ... → 环入口 → ... → 相遇点 → ... → 环入口
          a步          b步         c步

设环长度 = b + c

相遇时：
- 慢指针走了：a + b
- 快指针走了：a + b + n(b + c)  // n为快指针多走的圈数

由于快指针速度是慢指针2倍：
a + b + n(b + c) = 2(a + b)

化简得：a = (n-1)(b + c) + c

含义：从起点走a步 = 从相遇点走(n-1)圈再走c步
```

### 算法精髓
**第二阶段的神奇之处**：
- 一个指针从起点开始
- 一个指针从相遇点开始  
- 两者以相同速度前进
- 必定在环入口相遇！

### 我犯过的错误
```cpp
// ❌ 边界条件不足
while (fast != nullptr) {  // 缺少fast->next检查
    fast = fast->next->next;  // 可能访问nullptr->next崩溃
}

// ❌ 未处理无环情况
// 第一阶段结束后没有判断是否真的找到了环

// ✅ 正确的边界检查
while (fast != nullptr && fast->next != nullptr) {
    // 安全的指针移动
}
```

---

## 链表算法核心套路总结

### 1. 虚拟头节点模式
**使用场景**：头节点可能被删除或交换
```cpp
ListNode* dummy = new ListNode(0);
dummy->next = head;
// ... 操作
ListNode* result = dummy->next;
delete dummy;
return result;
```

### 2. 快慢双指针模式
**使用场景**：
- 找中点：快指针走2步，慢指针走1步
- 检测环：快指针追上慢指针
- 倒数第k个：快指针先走k步

### 3. 双指针同步模式
**使用场景**：
- 相交链表：让两个指针走相同总距离
- 环入口：从不同起点同步前进

### 4. 指针操作三要素
1. **保存关键节点**：修改指针前先保存
2. **操作顺序**：先保存后续连接，再修改当前
3. **边界检查**：访问指针前检查非空

## 我的错误总结

### C++语法层面
```cpp

// ❌ 循环条件错误
while (ptr != nullptr)  // 可能导致无限循环或访问越界

// ❌ 指针操作顺序错误  
// 先修改指针再保存，导致链表断裂
```

### 算法理解层面
```cpp
// ❌ 边界条件考虑不全
// 空链表、单节点、特殊情况未处理

// ❌ 数学原理理解不透
// 知其然不知其所以然，容易在变形题目中出错
```

### 内存管理
```cpp
// ❌ 忘记释放内存
delete dummy;          // 虚拟头节点
delete nodeToDelete;   // 被删除的节点
```

## 学习心得

### 今日收获
1. **掌握了链表的高级操作技巧**：交换、删除、查找
2. **理解了双指针的多种应用模式**：快慢、同步、错位
3. **学会了复杂链表问题的数学分析**：距离计算、环形结构推理
4. **提升了边界条件处理能力**：空指针、边界检查

### 算法思维进步
- **模式识别**：看到题目能快速识别应用哪种指针技巧
- **数学建模**：将链表问题转化为数学关系求解
- **边界意识**：养成了检查边界条件的习惯

### 链表题目规律
1. **90%的链表题都可以用双指针解决**
2. **虚拟头节点是处理头节点变化的万能钥匙**
3. **快慢指针是解决距离相关问题的利器**


### 学习方法总结
1. **画图理解**：复杂的指针操作必须画图
2. **数学推导**：不要只记结论，要理解推导过程
3. **边界测试**：空链表、单节点、特殊情况都要考虑
4. **代码规范**：指针操作顺序、内存管理、变量命名

### 学习时长
今日学习时长：6小时
- 理论学习：2小时
- 编程实践：2.5小时
- 调试改错：1小时
- 总结整理：0.5小时


