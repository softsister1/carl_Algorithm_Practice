# 代码随想录算法训练营第三天 | 链表part01

## 今日任务
- 链表理论基础
- 203. 移除链表元素
- 707. 设计链表
- 206. 反转链表

## 学习资源
- 文章链接：[链表理论基础](https://programmercarl.com/链表理论基础.html)
- 视频讲解：[移除链表元素](https://www.bilibili.com/video/BV18B4y1s7R9)

---

## 链表理论基础

### 链表定义
链表是一种通过指针串联在一起的线性结构，每个节点由两部分组成：数据域和指针域。

### 链表vs数组对比
| 特性 | 数组 | 链表 |
|------|------|------|
| **内存分布** | 连续 | 不连续 |
| **访问方式** | 随机访问 O(1) | 顺序访问 O(n) |
| **插入删除** | O(n) | O(1) |
| **内存开销** | 只存数据 | 数据+指针 |

### C++链表节点结构
```cpp
struct ListNode {
    int val;           // 数据域
    ListNode *next;    // 指针域
    
    // 构造函数
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

### 关键概念
- **指针操作**：`node->val` 访问数据，`node->next` 访问下一个节点
- **内存管理**：`new` 创建节点，`delete` 释放内存
- **空指针**：`nullptr` 表示链表结束

---

## 203. 移除链表元素

### 题目描述
给你一个链表的头节点head和一个整数val，删除链表中所有满足Node.val == val的节点，并返回新的头节点。

### 解题难点
- **头节点可能被删除**：需要特殊处理
- **连续节点删除**：需要正确维护指针关系
- **内存管理**：删除节点要释放内存

### 虚拟头节点解法 ⭐
```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 创建虚拟头节点
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        
        ListNode* current = dummy;
        
        while (current->next != nullptr) {
            if (current->next->val == val) {
                ListNode* nodeToDelete = current->next;
                current->next = current->next->next;
                delete nodeToDelete;  // 释放内存
            } else {
                current = current->next;
            }
        }
        
        ListNode* newHead = dummy->next;
        delete dummy;
        return newHead;
    }
};
```

### 核心思想
1. **虚拟头节点**：将头节点删除变为普通节点删除
2. **统一处理**：所有删除操作都变成删除current->next
3. **内存安全**：及时释放删除的节点

---

## 707. 设计链表

### 题目描述
设计链表的实现，支持get、addAtHead、addAtTail、addAtIndex、deleteAtIndex操作。

### 实现思路
使用**虚拟头节点 + size追踪**的设计：

```cpp
class MyLinkedList {
private:
    struct ListNode {
        int val;
        ListNode* next;
        ListNode(int x) : val(x), next(nullptr) {}
    };
    
    ListNode* dummy;  // 虚拟头节点
    int size;         // 链表长度
    
    // 辅助函数：获取第index个节点
    ListNode* getNode(int index) {
        if (index < 0 || index >= size) return nullptr;
        
        ListNode* current = dummy->next;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        return current;
    }
    
    // 辅助函数：获取第index-1个节点
    ListNode* getPrevNode(int index) {
        if (index < 0 || index > size) return nullptr;
        
        ListNode* current = dummy;
        for (int i = 0; i < index; i++) {
            current = current->next;
        }
        return current;
    }

public:
    MyLinkedList() {
        dummy = new ListNode(0);
        size = 0;
    }
    
    int get(int index) {
        ListNode* node = getNode(index);
        return node ? node->val : -1;
    }
    
    void addAtHead(int val) {
        ListNode* newNode = new ListNode(val);
        newNode->next = dummy->next;
        dummy->next = newNode;
        size++;
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if (index > size) return;
        if (index < 0) index = 0;
        
        ListNode* prev = getPrevNode(index);
        if (prev == nullptr) return;
        
        ListNode* newNode = new ListNode(val);
        newNode->next = prev->next;
        prev->next = newNode;
        size++;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) return;
        
        ListNode* prev = getPrevNode(index);
        if (prev == nullptr || prev->next == nullptr) return;
        
        ListNode* nodeToDelete = prev->next;
        prev->next = nodeToDelete->next;
        delete nodeToDelete;
        size--;
    }
};
```

### 设计要点
1. **虚拟头节点**：简化边界处理
2. **辅助函数**：`getNode()`获取节点，`getPrevNode()`获取前驱
3. **size维护**：避免重复遍历计算长度
4. **内存管理**：构造函数创建dummy，析构函数释放所有节点

### 时间复杂度
- get(index): O(n)
- addAtHead(val): O(1)  
- addAtTail(val): O(n)
- addAtIndex(index, val): O(n)
- deleteAtIndex(index): O(n)

---

## 206. 反转链表

### 题目描述
给你单链表的头节点head，请你反转链表，并返回反转后的链表。

### 双指针解法 ⭐
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        
        while (cur != nullptr) {
            ListNode* temp = cur->next;  // 保存下一个节点
            cur->next = pre;             // 反转指针
            pre = cur;                   // 移动pre
            cur = temp;                  // 移动cur
        }
        
        return pre;  // pre是新的头节点
    }
};
```

### 算法核心思想
```
反转过程：
原链表：1 -> 2 -> 3 -> NULL

步骤1：NULL <- 1    2 -> 3 -> NULL
       pre   cur   temp

步骤2：NULL <- 1 <- 2    3 -> NULL  
              pre  cur   temp

步骤3：NULL <- 1 <- 2 <- 3    NULL
                     pre     cur
```

### 关键要点
1. **三指针维护**：pre（前驱）、cur（当前）、temp（临时保存）
2. **指针反转**：cur->next = pre
3. **指针移动**：pre = cur, cur = temp
4. **返回值**：pre是新的头节点

### 递归解法（进阶）
```cpp
ListNode* reverseList(ListNode* head) {
    // 递归终止条件
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    
    // 递归反转后续链表
    ListNode* newHead = reverseList(head->next);
    
    // 反转当前节点
    head->next->next = head;
    head->next = nullptr;
    
    return newHead;
}
```

---

## 我犯过的错误总结

### 1. C++语法错误
```cpp
// ❌ struct定义后缺少分号
struct ListNode {
    // ...
}  // 缺少分号

// ✅ 正确写法
struct ListNode {
    // ...
};  // 需要分号
```

### 2. 指针操作错误
```cpp
// ❌ 返回错误的成员
return node ? node->index : -1;  // ListNode没有index成员

// ✅ 正确写法
return node ? node->val : -1;    // 应该返回val
```

### 3. 边界条件错误
```cpp
// ❌ 边界条件错误
if (index < 0 || index > size)   // size位置不存在

// ✅ 正确边界
if (index < 0 || index >= size)  // 有效范围[0, size-1]
```

### 4. 插入逻辑错误
```cpp
// ❌ 错误理解：在目标位置节点后插入
ListNode* node = getNode(index);
newNode->next = node->next;
node->next = newNode;

// ✅ 正确理解：在目标位置前插入，需要找前驱节点
ListNode* prev = getPrevNode(index);
newNode->next = prev->next;
prev->next = newNode;
```

### 5. 内存管理缺失
```cpp
// ❌ 删除节点但不释放内存
current->next = current->next->next;  // 内存泄漏

// ✅ 正确处理
ListNode* nodeToDelete = current->next;
current->next = nodeToDelete->next;
delete nodeToDelete;  // 释放内存
```

---

## 学习总结

### 今日收获
1. **掌握了链表基本操作**：遍历、插入、删除、反转
2. **理解了虚拟头节点的作用**：简化边界处理，统一操作逻辑
3. **学会了双指针技巧**：在链表反转中的经典应用
4. **提升了C++指针操作能力**：正确使用new/delete，避免内存泄漏

### 链表解题套路
1. **虚拟头节点**：处理头节点可能被删除的情况
2. **双指针遍历**：一个指向当前，一个指向前驱
3. **临时变量保存**：修改指针前先保存下一个节点
4. **边界检查**：空链表、单节点、索引越界
5. **内存管理**：及时释放删除的节点

### 常见错误类型
- **语法错误**：struct分号、指针操作符
- **逻辑错误**：边界条件、插入位置理解
- **内存错误**：忘记delete、访问空指针
- **理解偏差**：getPrevNode vs getNode的作用

### 优化思路
1. **时间复杂度**：链表访问是O(n)，无法像数组那样O(1)随机访问
2. **空间复杂度**：合理使用辅助指针，避免递归栈过深
3. **代码简洁性**：虚拟头节点统一处理，减少特判

### 链表vs数组选择
- **频繁插入删除** → 选择链表
- **频繁随机访问** → 选择数组
- **内存敏感场景** → 考虑链表的指针开销

