# 代码随想录算法训练营第二天 | 数组part02

## 今日任务
- 209. 长度最小的子数组
- 59. 螺旋矩阵 II
- 区间求和（ACM模式）
- 开发商购买土地（模拟笔试）

## 学习资源
- 文章链接：[滑动窗口](https://programmercarl.com/0209.长度最小的子数组.html)
- 视频讲解：[螺旋矩阵](https://www.bilibili.com/video/BV1SL4y1N7mV)

---

## 209. 长度最小的子数组

### 题目描述
给定一个含有n个正整数的数组和一个正整数target，找出该数组中满足其总和大于等于target的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回0。

### 解题思路

#### 暴力解法 O(n²)
枚举所有子数组，计算和并比较。

#### 滑动窗口法 O(n) ⭐
```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0;
        int minLength = INT_MAX;
        int sum = 0;
        
        for (int right = 0; right < nums.size(); right++) {
            // 扩大窗口
            sum += nums[right];
            
            // 当窗口和满足条件时，尝试缩小窗口
            while (sum >= target) {
                minLength = min(minLength, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }
        
        return minLength == INT_MAX ? 0 : minLength;
    }
};
```

### 滑动窗口核心思想
- **右指针扩大窗口**：寻找可行解
- **左指针缩小窗口**：寻找最优解
- **动态维护窗口状态**：避免重复计算

### 我犯过的错误
```cpp
// ❌ 错误的初始化
int minlength = nums.size();  // 导致边界case错误
return minlength == nums.size() ? 0 : minlength;

// ✅ 正确的初始化
int minLength = INT_MAX;
return minLength == INT_MAX ? 0 : minLength;
```

---

## 59. 螺旋矩阵 II

### 题目描述
给你一个正整数n，生成一个包含1到n²所有元素，且元素按顺时针顺序螺旋排列的n×n正方形矩阵。

### 解题思路

#### 方向控制法
```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> matrix(n, vector<int>(n, 0));
        int row = 0, col = 0;
        int direction = 0;  // 0:右, 1:下, 2:左, 3:上
        
        int dr[] = {0, 1, 0, -1};  // 行变化
        int dc[] = {1, 0, -1, 0};  // 列变化
        
        for (int i = 1; i <= n * n; i++) {
            matrix[row][col] = i;
            
            // 计算下一个位置
            int nextRow = row + dr[direction];
            int nextCol = col + dc[direction];
            
            // 判断是否需要转向
            if (nextRow < 0 || nextRow >= n || 
                nextCol < 0 || nextCol >= n || 
                matrix[nextRow][nextCol] != 0) {
                
                direction = (direction + 1) % 4;  // 顺时针转向
                nextRow = row + dr[direction];
                nextCol = col + dc[direction];
            }
            
            row = nextRow;
            col = nextCol;
        }
        return matrix;
    }
};
```

### 核心技巧
1. **方向数组**：用数组统一处理四个方向的移动
2. **转向条件**：越界或碰到已填充的格子
3. **顺时针转向**：`(direction + 1) % 4`

### 我犯过的错误
```cpp
// ❌ 错误的转向条件
if ((row == n) || (col == n) || (Matrix[row + 1][col] > 0))

// ✅ 正确的转向条件  
if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || 
    matrix[nextRow][nextCol] != 0)
```

---

## 区间求和（ACM模式练习）

### 题目描述
给定一个整数数组，计算该数组在每个指定区间内元素的总和。

### 解题代码
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    int left, right;
    while (cin >> left >> right) {
        int sum = 0;
        for (int i = left; i <= right; i++) {
            sum += nums[i];
        }
        cout << sum << endl;
    }
    
    return 0;
}
```

### 我犯过的基础语法错误
```cpp
// ❌ 输入输出操作符错误
cin << n;        // 应该是 >>
cout >> sum;     // 应该是 <<

// ❌ vector声明错误
vector(int) nums(n);  // 应该是 vector<int>

// ❌ 变量未声明
for(i = left; i < right; i++)  // 应该是 for(int i = ...)

// ❌ 区间范围错误
i < right  // 应该是 i <= right（包含右端点）
```

---

## 开发商购买土地（模拟笔试）

### 题目描述
在一个n×m的城市区域内，每个区块都有不同的权值。需要将这个区域按横向或纵向划分成两个子区域，使得两个子区域内土地总价值之差最小。

### 解题思路

#### 枚举分割线
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    
    int totalSum = 0;
    vector<vector<int>> matrix(n, vector<int>(m, 0));
    
    // 读取矩阵并计算总和
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> matrix[i][j];
            totalSum += matrix[i][j];
        }
    }
    
    int minDiff = INT_MAX;
    
    // 纵向分割：在第col列和第col+1列之间切割
    for (int col = 0; col < m - 1; col++) {
        int leftSum = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= col; j++) {
                leftSum += matrix[i][j];
            }
        }
        int rightSum = totalSum - leftSum;
        int diff = abs(leftSum - rightSum);
        minDiff = min(minDiff, diff);
    }
    
    // 横向分割：在第row行和第row+1行之间切割  
    for (int row = 0; row < n - 1; row++) {
        int topSum = 0;
        for (int i = 0; i <= row; i++) {
            for (int j = 0; j < m; j++) {
                topSum += matrix[i][j];
            }
        }
        int bottomSum = totalSum - topSum;
        int diff = abs(topSum - bottomSum);
        minDiff = min(minDiff, diff);
    }
    
    cout << minDiff << endl;
    return 0;
}
```

### 我犯过的语法错误
```cpp
// ❌ 头文件拼写错误
#include <iosteram>  // 应该是 iostream

// ❌ 变量名不一致
int totalsum = 0;         // 小写
totalSum += matrix[i][j]; // 驼峰命名

// ❌ 缺少必要声明
// 没有 using namespace std;
// 没有声明 minDiff 变量
// 没有包含 <algorithm> 头文件
```

---

## 学习总结

### 今日收获
1. **掌握了滑动窗口技巧**：用双指针解决子数组问题，时间复杂度从O(n²)优化到O(n)
2. **学会了方向控制算法**：用方向数组处理螺旋矩阵填充问题
3. **熟练了ACM输入输出模式**：处理多组输入，理解题目格式要求
4. **提升了代码调试能力**：通过犯错和修正，加深对语法细节的理解

### 算法思维进步
- **滑动窗口思想**：动态维护窗口状态，避免重复计算
- **边界条件处理**：转向判断、越界检查、特殊情况分析
- **复杂度优化意识**：从暴力解法思考到最优解法


### 学习时长
今日学习时长：5小时
- 理论学习：1.5小时
- 编程实践：2.5小时
- 调试修错：1小时

### 明日计划
继续学习字符串相关算法，重点关注KMP算法的理解和实现。

